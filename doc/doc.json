{
    "name": "./",
    "subfolders": [
        {
            "name": "./Algorithms",
            "subfolders": [
                {
                    "name": "./Algorithms/Search",
                    "subfolders": [],
                    "files": [
                        {
                            "functions": [
                                {
                                    "doc": "/**\n * @brief Linear search algorithm\n * @param arr Array to search\n * @param length Length of the array\n * @param target Target to search\n * @param cmp Comparison function\n */",
                                    "header": "size_t\tLinearSearch(const Generic *arr, size_t length, Generic target,\n\t\tComparator cmp)",
                                    "body": "{\n\tsize_t\tcount;\n\n\tcount = 0;\n\twhile (count < length)\n\t{\n\t\tif (!cmp(arr[count], target))\n\t\t\treturn (count);\n\t\tcount++;\n\t}\n\treturn (-1);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "size_t\tBinarySearch(const Generic *arr, size_t length, Generic target,\n\t\tComparator cmp)",
                                    "body": "{\n\tsize_t\tleft;\n\tsize_t\tright;\n\tsize_t\tmid;\n\n\tleft = 0;\n\tright = length - 1;\n\twhile (left <= right)\n\t{\n\t\tmid = left + (right - left) / 2;\n\t\tif (!cmp(arr[mid], target))\n\t\t\treturn (mid);\n\t\tif (cmp(arr[mid], target) > 0)\n\t\t\tleft = mid + 1;\n\t\telse\n\t\t\tright = mid - 1;\n\t}\n\treturn (-1);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "./Algorithms/Sort",
                    "subfolders": [],
                    "files": [
                        {
                            "functions": [
                                {
                                    "doc": "/**\n * O(n)\n *\n * @brief range[0, 1) => 10 buckets of linked lists\n * @param array\n * @param size\n * @warning not runnable\n */",
                                    "header": "void\tswap(Generic *a, Generic *b)",
                                    "body": "{\n\tGeneric\ttemp;\n\n\ttemp = *a;\n\t*a = *b;\n\t*b = temp;\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tBubbleSort(Generic *array, size_t size, Comparator cmp)",
                                    "body": "{\n\tbool\tswapped;\n\n\tswapped = true;\n\twhile (swapped)\n\t{\n\t\tswapped = false;\n\t\tfor (size_t i = 0; i < size - 1; i++)\n\t\t{\n\t\t\tif (cmp(array[i], array[i + 1]) > 0)\n\t\t\t{\n\t\t\t\tswap(array + i, array + i + 1);\n\t\t\t\tswapped = true;\n\t\t\t}\n\t\t}\n\t}\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tInsertionSort(Generic *array, size_t size, Comparator cmp)",
                                    "body": "{\n\tsize_t\tcurrentIndex;\n\n\tfor (size_t i = 1; i < size; i++)\n\t{\n\t\tcurrentIndex = i;\n\t\twhile (currentIndex > 0 && cmp(array[currentIndex], array[currentIndex\n\t\t\t\t- 1]) < 0)\n\t\t{\n\t\t\tswap(array + currentIndex, array + currentIndex - 1);\n\t\t\tcurrentIndex--;\n\t\t}\n\t}\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tMerge(Generic *arr, size_t low, size_t mid, size_t high, Comparator cmp)",
                                    "body": "{\n\tconst size_t\ttempLength = high - low + 1;\n\tGeneric\t\t\t*temp[tempLength];\n\tsize_t\t\t\tleft;\n\tsize_t\t\t\tright;\n\tsize_t\t\t\ttempCounter;\n\n\tif (!arr)\n\t\treturn ;\n\t// pointers to the left and right sub-arrays\n\tleft = low;\n\tright = mid + 1;\n\ttempCounter = 0;\n\t// basic merge\n\twhile (left <= mid && right <= high)\n\t{\n\t\tif (cmp(arr[left], arr[right]) > 0)\n\t\t\ttemp[tempCounter++] = arr[right++];\n\t\telse\n\t\t\ttemp[tempCounter++] = arr[left++];\n\t}\n\t// copy the rest of the sub-array that still has elements\n\tif (right > high)\n\t\twhile (left <= mid)\n\t\t\ttemp[tempCounter++] = arr[left++];\n\telse\n\t\twhile (right <= high)\n\t\t\ttemp[tempCounter++] = arr[right++];\n\t// copy temp to arr\n\tfor (size_t i = 0; i < tempLength; i++)\n\t\tarr[low + i] = temp[i];\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tMergeSort_rec(Generic *arr, size_t low, size_t high, Comparator cmp)",
                                    "body": "{\n\tsize_t\tmid;\n\n\t// low < high when there are at least 2 elements\n\tif (low >= high)\n\t\treturn ;\n\tmid = (low + high) / 2;\n\tMergeSort_rec(arr, low, mid, cmp);\n\tMergeSort_rec(arr, mid + 1, high, cmp);\n\tMerge(arr, low, mid, high, cmp);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tMergeSort(Generic *array, size_t size, Comparator cmp)",
                                    "body": "{\n\tMergeSort_rec(array, 0, size - 1, cmp);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tQuickSort_rec(int *arr, size_t low, size_t high)",
                                    "body": "{\n\tsize_t\tleft;\n\tsize_t\tright;\n\tint\t\tpivot;\n\n\tif (low < high)\n\t{\n\t\tleft = low;\n\t\tright = high;\n\t\tpivot = arr[low];\n\t\t// partition\n\t\twhile (left < right)\n\t\t{\n\t\t\twhile (arr[right] > pivot)\n\t\t\t\tright--;\n\t\t\twhile (left < right && arr[left] <= pivot)\n\t\t\t\tleft++;\n\t\t\tif (left < right)\n\t\t\t\tswap((void *)(arr + left), (void *)(arr + right));\n\t\t}\n\t\t// fix pivot position\n\t\tif (low != right)\n\t\t{\n\t\t\tarr[low] = arr[right];\n\t\t\tarr[right] = pivot;\n\t\t}\n\t\t// recursive calls\n\t\tif (right - 1 > low)\n\t\t\tQuickSort_rec(arr, low, right - 1);\n\t\tif (right + 1 < high)\n\t\t\tQuickSort_rec(arr, right + 1, high);\n\t}\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tQuickSort(int *array, size_t size)",
                                    "body": "{\n\tQuickSort_rec(array, 0, size - 1);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tCountingSort(const int array[], int dest[], int size, int k)",
                                    "body": "{\n\tint\tc[k + 1];\n\tint\tn_lower;\n\n\tint i, j;\n\t// number of elements lower than the current element\n\tmemset(c, 0, (k + 1) * sizeof(int));\n\tfor (j = 0; j < size; j++)\n\t\tc[array[j]] += 1;\n\tfor (i = 1; i < k + 1; i++)\n\t\tc[i] = c[i] + c[i - 1];\n\tfor (j = size - 1; j >= 0; j--)\n\t{\n\t\tn_lower = c[array[j]] - 1;\n\t\tdest[n_lower] = array[j];\n\t\tc[array[j]] -= 1;\n\t\tLog_intarray(dest, size, n_lower);\n\t}\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tBucketSort(Generic *array, int size)",
                                    "body": "{\n\tint index __attribute__((unused));\n\tLinkedList buckets[size] __attribute__((unused));\n\tfor (int i = 0; i < size; i++)\n\t\tbuckets[i] = LINKEDLIST_EMPTY;\n\tfor (int i = 1; i <= size; i++)\n\t{\n\t\tindex = floor(size * (*(int *)array[i]));\n\t\t// LinkedList_Append(buckets + index, array[i]);\n\t}\n\tfor (int i = 0; i < size; i++)\n\t{\n\t\t// InsertionSort(bucket[i], &LinkedList_Cmp)\n\t\t// concat lists\n\t}\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                }
                            ]
                        }
                    ]
                }
            ],
            "files": []
        },
        {
            "name": "./libft",
            "subfolders": [],
            "files": [
                {
                    "functions": [
                        {
                            "doc": "",
                            "header": "char\tis_sep(char c)",
                            "body": "{\n\tchar\t*l;\n\n\tl = \"\\t\\n\\r\\v\\f \";\n\twhile (*l)\n\t{\n\t\tif (*l == c)\n\t\t\treturn (1);\n\t\tl++;\n\t}\n\treturn (0);\n}",
                            "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                            "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                            "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                        },
                        {
                            "doc": "",
                            "header": "int\tft_is_sign(int c)",
                            "body": "{\n\treturn (c == '+' || c == '-');\n}",
                            "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                            "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                            "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                        },
                        {
                            "doc": "",
                            "header": "int\tft_atoi(const char *nptr)",
                            "body": "{\n\tint\tout;\n\tint\tsign_count;\n\tint\tsign;\n\n\tif (!*nptr)\n\t\treturn (0);\n\twhile (is_sep(*nptr))\n\t\tnptr++;\n\tsign_count = 0;\n\tsign = 1;\n\twhile (ft_is_sign(*nptr))\n\t{\n\t\tif (*nptr++ == '-')\n\t\t\tsign = -1;\n\t\tif (sign_count)\n\t\t\treturn (0);\n\t\tsign_count++;\n\t}\n\tout = 0;\n\twhile (ft_isdigit(*nptr))\n\t{\n\t\tout = out * 10 + *nptr - '0';\n\t\tnptr++;\n\t}\n\treturn (out * sign);\n}",
                            "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                            "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                            "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                        }
                    ]
                },
                {
                    "functions": [
                        {
                            "doc": "",
                            "header": "",
                            "body": "{\n\tsize_t\tlen;\n\tchar\t*addr;\n\n\tlen = ft_strlen(s);\n\taddr = malloc(sizeof(char) * (len + 1));\n\tif (!addr)\n\t\treturn (NULL);\n\tft_strlcpy(addr, s, len + 1);\n\treturn (addr);\n}",
                            "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                            "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                            "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                        }
                    ]
                },
                {
                    "functions": [
                        {
                            "doc": "",
                            "header": "",
                            "body": "{\n\tchar\t*new_string;\n\tsize_t\tlen;\n\tsize_t\ti;\n\tsize_t\tj;\n\n\tif (!s1 || !s2)\n\t\treturn (NULL);\n\tlen = ft_strlen(s1) + ft_strlen(s2);\n\tnew_string = (char *) malloc(sizeof(char) * (len + 1));\n\tif (!new_string)\n\t\treturn (NULL);\n\ti = 0;\n\twhile (s1[i])\n\t{\n\t\tnew_string[i] = s1[i];\n\t\ti++;\n\t}\n\tj = 0;\n\twhile (s2[j])\n\t{\n\t\tnew_string[i + j] = s2[j];\n\t\tj++;\n\t}\n\tnew_string[i + j] = '\\0';\n\treturn (new_string);\n}",
                            "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                            "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                            "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                        }
                    ]
                },
                {
                    "functions": [
                        {
                            "doc": "",
                            "header": "int\tft_tolower(int c)",
                            "body": "{\n\tif (c >= 'A' && c <= 'Z')\n\t\treturn (c + ('a' - 'A'));\n\treturn (c);\n}",
                            "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                            "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                            "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                        }
                    ]
                },
                {
                    "functions": [
                        {
                            "doc": "",
                            "header": "size_t\tint_len(int n, size_t iter)",
                            "body": "{\n\tif (!n && !iter)\n\t\treturn (1);\n\tif (!n)\n\t\treturn (0);\n\treturn (1 + int_len(n / 10, iter + 1));\n}",
                            "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                            "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                            "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                        },
                        {
                            "doc": "",
                            "header": "void\tint_to_str(char *addr, int n, size_t len)",
                            "body": "{\n\tchar\tis_neg;\n\n\tis_neg = (n < 0);\n\tif (is_neg)\n\t\tn = -n;\n\twhile (len >= 1)\n\t{\n\t\taddr[len - 1] = '0' + n % 10;\n\t\tn /= 10;\n\t\tlen--;\n\t}\n\tif (is_neg)\n\t\taddr[0] = '-';\n}",
                            "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                            "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                            "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                        },
                        {
                            "doc": "",
                            "header": "",
                            "body": "{\n\tchar\t*str;\n\tsize_t\tlen;\n\n\tlen = int_len(n, 0) + 1 + 1 * (n < 0);\n\tstr = (char *) malloc(sizeof(char) * (len));\n\tif (!str)\n\t\treturn (NULL);\n\tif (n == -2147483648)\n\t{\n\t\tft_memcpy(str, \"-2147483648\\0\", len);\n\t\treturn (str);\n\t}\n\tint_to_str(str, n, len - 1);\n\tstr[len - 1] = '\\0';\n\treturn (str);\n}",
                            "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                            "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                            "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                        }
                    ]
                },
                {
                    "functions": [
                        {
                            "doc": "",
                            "header": "int\tis_in_string(char const c, char const *s)",
                            "body": "{\n\tsize_t\ti;\n\n\ti = 0;\n\twhile (s[i])\n\t{\n\t\tif (c == s[i])\n\t\t\treturn (1);\n\t\ti++;\n\t}\n\treturn (0);\n}",
                            "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                            "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                            "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                        },
                        {
                            "doc": "",
                            "header": "",
                            "body": "{\n\tsize_t\tleft;\n\tsize_t\tright;\n\tchar\t*new_string;\n\n\tif (!s1 || !set)\n\t\treturn (NULL);\n\tleft = 0;\n\tright = ft_strlen(s1) - 1;\n\twhile (is_in_string(s1[left], set))\n\t\tleft++;\n\tif (left > right)\n\t\treturn (ft_strdup(\"\"));\n\twhile (is_in_string(s1[right], set))\n\t\tright--;\n\tnew_string = (char *) malloc(sizeof(char) * (right - left + 2));\n\tif (!new_string)\n\t\treturn (NULL);\n\tft_strlcpy(new_string, s1 + left, right - left + 2);\n\treturn (new_string);\n}",
                            "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                            "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                            "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                        }
                    ]
                },
                {
                    "functions": [
                        {
                            "doc": "",
                            "header": "",
                            "body": "{\n\tchar\t*addr;\n\n\taddr = (char *) malloc(nmemb * size);\n\tif (!addr)\n\t\treturn (0);\n\tft_bzero(addr, nmemb * size);\n\treturn (addr);\n}",
                            "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                            "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                            "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                        }
                    ]
                },
                {
                    "functions": [
                        {
                            "doc": "",
                            "header": "int\tft_isalpha(int c)",
                            "body": "{\n\tint\tisupper;\n\tint\tislower;\n\n\tisupper = (c >= 'A' && c <= 'Z');\n\tislower = (c >= 'a' && c <= 'z');\n\treturn (isupper || islower);\n}",
                            "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                            "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                            "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                        }
                    ]
                },
                {
                    "functions": [
                        {
                            "doc": "",
                            "header": "void\tft_bzero(void *b, size_t n)",
                            "body": "{\n\tft_memset(b, 0, n);\n}",
                            "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                            "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                            "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                        }
                    ]
                },
                {
                    "functions": [
                        {
                            "doc": "",
                            "header": "void\tft_striteri(char *s, void (*f)(unsigned int, char *))",
                            "body": "{\n\tunsigned int\ti;\n\n\tif (!s)\n\t\treturn ;\n\ti = 0;\n\twhile (*s && f)\n\t\tf(i++, s++);\n}",
                            "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                            "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                            "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                        }
                    ]
                },
                {
                    "functions": [
                        {
                            "doc": "",
                            "header": "size_t\tft_strlcpy(char *dest, const char *src, size_t size)",
                            "body": "{\n\tsize_t\ti;\n\n\tif (size == 0)\n\t\treturn (ft_strlen(src));\n\ti = 0;\n\twhile (i < size - 1 && src[i])\n\t{\n\t\tdest[i] = src[i];\n\t\ti++;\n\t}\n\tdest[i] = '\\0';\n\treturn (ft_strlen(src));\n}",
                            "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                            "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                            "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                        }
                    ]
                },
                {
                    "functions": [
                        {
                            "doc": "",
                            "header": "",
                            "body": "{\n\tunsigned int\ti;\n\tunsigned int\ts_len;\n\tchar\t\t\t*new_string;\n\n\tif (!s || !f)\n\t\treturn (NULL);\n\ts_len = (unsigned int)ft_strlen(s);\n\tnew_string = (char *) malloc(sizeof(char) * (s_len + 1));\n\tif (!new_string)\n\t\treturn (NULL);\n\ti = 0;\n\twhile (i < s_len)\n\t{\n\t\tnew_string[i] = f(i, s[i]);\n\t\ti++;\n\t}\n\tnew_string[i] = '\\0';\n\treturn (new_string);\n}",
                            "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                            "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                            "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                        }
                    ]
                },
                {
                    "functions": [
                        {
                            "doc": "",
                            "header": "size_t\tcnt_split(char const *s, char c, size_t *i, size_t *j)",
                            "body": "{\n\tsize_t\tcount;\n\tchar\twas_sep;\n\n\tcount = 0;\n\twas_sep = 1;\n\t*i = 0;\n\t*j = 0;\n\twhile (*s)\n\t{\n\t\tif (was_sep && *s != c)\n\t\t\tcount++;\n\t\twas_sep = *s == c;\n\t\ts++;\n\t}\n\treturn (count);\n}",
                            "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                            "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                            "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                        },
                        {
                            "doc": "",
                            "header": "",
                            "body": "{\n\tchar\t**arr;\n\tsize_t\tind[2];\n\tsize_t\twords;\n\tsize_t\tcount;\n\n\tif (!s)\n\t\treturn (NULL);\n\twords = cnt_split(s, c, ind, ind + 1);\n\tarr = (char **) malloc(sizeof(char *) * (words + 1));\n\tif (!arr)\n\t\treturn (NULL);\n\tcount = 0;\n\twhile (count < words)\n\t{\n\t\tind[0] = ind[1];\n\t\twhile (s[ind[0]] && s[ind[0]] == c)\n\t\t\tind[0]++;\n\t\tind[1] = ind[0] + 1;\n\t\twhile (s[ind[1]] && s[ind[1]] != c)\n\t\t\tind[1]++;\n\t\tarr[count] = (char *) malloc(sizeof(char) * (ind[1] - ind[0] + 1));\n\t\tft_strlcpy(arr[count++], s + ind[0], ind[1] - ind[0] + 1);\n\t}\n\tarr[count] = NULL;\n\treturn (arr);\n}",
                            "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                            "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                            "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                        }
                    ]
                },
                {
                    "functions": [
                        {
                            "doc": "",
                            "header": "",
                            "body": "{\n\tchar\tcc;\n\tchar\t*ss;\n\n\tcc = (char) c;\n\tss = (char *)s;\n\twhile (*ss || cc == '\\0')\n\t{\n\t\tif (*ss == cc)\n\t\t\treturn (ss);\n\t\tss++;\n\t}\n\treturn (NULL);\n}",
                            "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                            "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                            "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                        }
                    ]
                },
                {
                    "functions": [
                        {
                            "doc": "",
                            "header": "",
                            "body": "{\n\tsize_t\ti;\n\tchar\t*ss;\n\n\tss = (char *)s;\n\ti = 0;\n\twhile (i < n)\n\t{\n\t\tss[i] = c;\n\t\ti++;\n\t}\n\treturn (s);\n}",
                            "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                            "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                            "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                        }
                    ]
                },
                {
                    "functions": [
                        {
                            "doc": "",
                            "header": "int\tft_isascii(int c)",
                            "body": "{\n\treturn (c >= 0 && c <= 127);\n}",
                            "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                            "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                            "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                        }
                    ]
                },
                {
                    "functions": [
                        {
                            "doc": "",
                            "header": "void\tft_putstr_fd(char *s, int fd)",
                            "body": "{\n\tif (!s)\n\t\treturn ;\n\twrite(fd, s, ft_strlen(s));\n}",
                            "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                            "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                            "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                        }
                    ]
                },
                {
                    "functions": [
                        {
                            "doc": "",
                            "header": "size_t\tft_strlen(const char *s)",
                            "body": "{\n\tsize_t\tc;\n\n\tc = 0;\n\twhile (*(s++))\n\t\tc++;\n\treturn (c);\n}",
                            "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                            "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                            "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                        }
                    ]
                },
                {
                    "functions": [
                        {
                            "doc": "",
                            "header": "",
                            "body": "{\n\tsize_t\ti;\n\tchar\t*ss;\n\n\ti = ft_strlen(s);\n\tss = (char *)s;\n\twhile (ss + i >= s)\n\t{\n\t\tif (s[i] == (unsigned char) c)\n\t\t\treturn (ss + i);\n\t\ti--;\n\t}\n\treturn (NULL);\n}",
                            "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                            "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                            "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                        }
                    ]
                },
                {
                    "functions": [
                        {
                            "doc": "",
                            "header": "int\tft_isalnum(int c)",
                            "body": "{\n\tint\tischar;\n\tint\tisnum;\n\n\tischar = (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');\n\tisnum = c >= '0' && c <= '9';\n\treturn (ischar || isnum);\n}",
                            "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                            "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                            "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                        }
                    ]
                },
                {
                    "functions": [
                        {
                            "doc": "",
                            "header": "int\tft_strncmp(const char *s1, const char *s2, size_t n)",
                            "body": "{\n\tsize_t\ti;\n\n\tif (!n)\n\t\treturn (0);\n\ti = 0;\n\twhile (i < n && s1[i] && s2[i])\n\t{\n\t\tif (s1[i] != s2[i])\n\t\t\treturn (s1[i] - s2[i]);\n\t\ti++;\n\t}\n\treturn (s1[i] - s2[i]);\n}",
                            "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                            "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                            "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                        }
                    ]
                },
                {
                    "functions": [
                        {
                            "doc": "",
                            "header": "",
                            "body": "{\n\tunsigned char\t*addr;\n\tunsigned char\tcc;\n\tsize_t\t\t\ti;\n\n\taddr = (unsigned char *)s;\n\tcc = (unsigned char)c;\n\ti = 0;\n\twhile (i < n)\n\t{\n\t\tif (addr[i] == cc)\n\t\t\treturn (addr + i);\n\t\ti++;\n\t}\n\treturn (NULL);\n}",
                            "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                            "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                            "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                        }
                    ]
                },
                {
                    "functions": [
                        {
                            "doc": "",
                            "header": "int\tft_memcmp(const void *b1, const void *b2, size_t n)",
                            "body": "{\n\tunsigned char\t*a;\n\tunsigned char\t*b;\n\tsize_t\t\t\ti;\n\tint\t\t\t\tdiff;\n\n\tif (!n)\n\t\treturn (0);\n\ta = (unsigned char *)b1;\n\tb = (unsigned char *)b2;\n\ti = 0;\n\twhile (i < n)\n\t{\n\t\tdiff = *(a + i) - *(b + i);\n\t\tif (diff != 0)\n\t\t\treturn (diff);\n\t\ti++;\n\t}\n\treturn (0);\n}",
                            "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                            "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                            "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                        }
                    ]
                },
                {
                    "functions": [
                        {
                            "doc": "",
                            "header": "",
                            "body": "{\n\tchar\t*new_string;\n\n\tif (!s)\n\t\treturn (NULL);\n\tif (start >= ft_strlen(s))\n\t\treturn (ft_strdup(\"\"));\n\tif (len > (ft_strlen(s) - start))\n\t\tlen = (ft_strlen(s) - start);\n\tnew_string = (char *) malloc(sizeof(char) * (len + 1));\n\tif (!new_string)\n\t\treturn (NULL);\n\tft_strlcpy(new_string, s + start, len + 1);\n\treturn (new_string);\n}",
                            "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                            "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                            "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                        }
                    ]
                },
                {
                    "functions": [
                        {
                            "doc": "",
                            "header": "int\tft_isdigit(int c)",
                            "body": "{\n\treturn (c >= '0' && c <= '9');\n}",
                            "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                            "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                            "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                        }
                    ]
                },
                {
                    "functions": [
                        {
                            "doc": "",
                            "header": "void\tft_putendl_fd(char *s, int fd)",
                            "body": "{\n\tif (!s)\n\t\treturn ;\n\twrite(fd, s, ft_strlen(s));\n\twrite(fd, \"\\n\", 1);\n}",
                            "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                            "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                            "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                        }
                    ]
                },
                {
                    "functions": [
                        {
                            "doc": "",
                            "header": "",
                            "body": "{\n\tchar\t*p_dest;\n\tchar\t*p_src;\n\tchar\toverlaps;\n\tint\t\ti;\n\n\tif (dest == src || !n)\n\t\treturn (dest);\n\tp_dest = (char *)dest;\n\tp_src = (char *)src;\n\toverlaps = (p_dest > p_src && p_dest - p_src < (int)n);\n\tif (overlaps)\n\t{\n\t\ti = n - 1;\n\t\twhile (i >= 0)\n\t\t{\n\t\t\tp_dest[i] = p_src[i];\n\t\t\ti--;\n\t\t}\n\t}\n\telse\n\t\tft_memcpy(dest, src, n);\n\treturn (dest);\n}",
                            "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                            "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                            "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                        }
                    ]
                },
                {
                    "functions": [
                        {
                            "doc": "",
                            "header": "void\tft_putchar_fd(char c, int fd)",
                            "body": "{\n\twrite(fd, &c, 1);\n}",
                            "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                            "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                            "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                        }
                    ]
                },
                {
                    "functions": [
                        {
                            "doc": "",
                            "header": "char\tft_starts_with(const char *s, const char *sub)",
                            "body": "{\n\treturn (ft_strncmp(s, sub, ft_strlen(sub)) == 0);\n}",
                            "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                            "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                            "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                        },
                        {
                            "doc": "",
                            "header": "",
                            "body": "{\n\tsize_t\ti;\n\tsize_t\tlittle_len;\n\n\tif (!*little || (!big && !len))\n\t\treturn ((char *)big);\n\ti = 0;\n\tlittle_len = ft_strlen(little);\n\twhile (big[i] && i + little_len - 1 < len)\n\t{\n\t\tif (ft_starts_with(big + i, little))\n\t\t\treturn ((char *)big + i);\n\t\ti++;\n\t}\n\treturn (NULL);\n}",
                            "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                            "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                            "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                        }
                    ]
                },
                {
                    "functions": [
                        {
                            "doc": "",
                            "header": "",
                            "body": "{\n\tchar\t*new_str;\n\n\tnew_str = ft_strjoin(s1, s2);\n\tfree(s1);\n\treturn (new_str);\n}",
                            "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                            "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                            "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                        }
                    ]
                },
                {
                    "functions": [
                        {
                            "doc": "",
                            "header": "void\tft_putnbr_fd(int n, int fd)",
                            "body": "{\n\tchar\tbuf;\n\n\tif (n < 0)\n\t{\n\t\tif (n == -2147483648)\n\t\t{\n\t\t\twrite(fd, \"-2147483648\", 11);\n\t\t\treturn ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\twrite(fd, \"-\", 1);\n\t\t\tn = -n;\n\t\t}\n\t}\n\tif (n > 9)\n\t\tft_putnbr_fd(n / 10, fd);\n\tbuf = '0' + (n % 10);\n\twrite(fd, &buf, 1);\n}",
                            "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                            "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                            "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                        }
                    ]
                },
                {
                    "functions": [
                        {
                            "doc": "",
                            "header": "size_t\tft_strlcat(char *dest, const char *src, size_t size)",
                            "body": "{\n\tsize_t\ti;\n\tsize_t\tdest_len;\n\tsize_t\tsrc_len;\n\n\tif (!size)\n\t\treturn (ft_strlen(src));\n\tdest_len = ft_strlen(dest);\n\tsrc_len = ft_strlen(src);\n\tif (size <= dest_len)\n\t\treturn (size + src_len);\n\ti = 0;\n\twhile (src[i] != '\\0' && dest_len + 1 + i < size)\n\t{\n\t\tdest[dest_len + i] = src[i];\n\t\ti++;\n\t}\n\tdest[dest_len + i] = '\\0';\n\treturn (dest_len + src_len);\n}",
                            "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                            "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                            "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                        }
                    ]
                },
                {
                    "functions": [
                        {
                            "doc": "",
                            "header": "int\tft_isprint(int c)",
                            "body": "{\n\treturn (c >= ' ' && c <= '~');\n}",
                            "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                            "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                            "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                        }
                    ]
                },
                {
                    "functions": [
                        {
                            "doc": "",
                            "header": "",
                            "body": "{\n\tchar\t*dest;\n\tchar\t*source;\n\tsize_t\ti;\n\n\tdest = (char *)dst;\n\tsource = (char *)src;\n\tif (!dest && !source)\n\t\treturn (NULL);\n\ti = 0;\n\twhile (i < n)\n\t{\n\t\tdest[i] = source[i];\n\t\ti++;\n\t}\n\treturn (dest);\n}",
                            "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                            "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                            "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                        }
                    ]
                },
                {
                    "functions": [
                        {
                            "doc": "",
                            "header": "int\tft_toupper(int c)",
                            "body": "{\n\tif (c >= 'a' && c <= 'z')\n\t\treturn (c - ('a' - 'A'));\n\treturn (c);\n}",
                            "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                            "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                            "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                        }
                    ]
                }
            ]
        },
        {
            "name": "./Utils",
            "subfolders": [
                {
                    "name": "./Utils/Logging",
                    "subfolders": [],
                    "files": [
                        {
                            "functions": [
                                {
                                    "doc": "",
                                    "header": "void Log_intarray(int *arr, size_t size, size_t new_index)",
                                    "body": "{\n\tprintf(\"[\\t\");\n\tsize_t i = 0;\n\twhile (i < size) {\n\t\tif (i == new_index)\n\t\t\tprintf(\"%s%d%s\\t\", GRN, arr[i], reset);\n\t\telse printf(\"%d\\t\", arr[i]);\n\t\ti++;\n\t}\n\tprintf(\"]\\n\");\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "./Utils/Compare",
                    "subfolders": [],
                    "files": [
                        {
                            "functions": [
                                {
                                    "doc": "",
                                    "header": "int\tCompare_String(Generic a, Generic b)",
                                    "body": "{\n\tif (!b && !a)\n\t\treturn (0);\n\tif (!a)\n\t\treturn (-1);\n\tif (!b)\n\t\treturn (1);\n\treturn (strcmp((char *)a, (char *)b));\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "int\tCompare_Int(Generic a, Generic b)",
                                    "body": "{\n\tint x;\n\tint y;\n\n\tif (!b && !a)\n\t\treturn (0);\n\tif (!a)\n\t\treturn (-1);\n\tif (!b)\n\t\treturn (1);\n\tx = *(int *)a;\n\ty = *(int *)b;\n\tif (x == y)\n\t\treturn (0);\n\tif (x < y)\n\t\treturn (-1);\n\treturn (1);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "int\tCompare_Uint64(Generic a, Generic b)",
                                    "body": "{\n\tif (!b && !a)\n\t\treturn (0);\n\tif (!a)\n\t\treturn (-1);\n\tif (!b)\n\t\treturn (1);\n\treturn (*(uint64_t *)a - *(uint64_t *)b);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "./Utils/Conversion",
                    "subfolders": [],
                    "files": [
                        {
                            "functions": [
                                {
                                    "doc": "",
                                    "header": "String uintToString(uint64_t n, size_t bits)",
                                    "body": "{\n\tsize_t i;\n\tString str;\n\n\tif (bits > 64)\n\t\treturn NULL;\n\ti = bits;\n\tstr = (String) malloc(sizeof(char) * (i + 1));\n\tif (!str)\n\t\treturn (NULL);\n\tstr[i] = 0;\n\twhile (i--)\n\t{\n\t\tstr[i] = '0' + (n & 1);\n\t\tn >>= 1;\n\t}\n\treturn (str);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "./Utils/Hashing",
                    "subfolders": [],
                    "files": [
                        {
                            "functions": [
                                {
                                    "doc": "/**\n * @brief\n *\n * @param bytes anything\n * @param size hashmap size\n * @return size_t\n */",
                                    "header": "size_t\tnormalize(size_t bytes, size_t size)",
                                    "body": "{\n\treturn (bytes % size);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "size_t\thash_int(Generic key, size_t size)",
                                    "body": "{\n\treturn (hash_generic((size_t)key, size));\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "size_t\thash_string(Generic key, size_t size)",
                                    "body": "{\n\tsize_t\thash;\n\tchar\t*str;\n\n\thash = 0;\n\tstr = (char *)key;\n\twhile (*str)\n\t{\n\t\thash = hash * 31 + *str;\n\t\tstr++;\n\t}\n\treturn (normalize(hash, size));\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "size_t\thash_generic(size_t bytes, size_t size)",
                                    "body": "{\n\tsize_t\tbin;\n\n\tbin = (size_t)bytes;\n\tbin = bin ^ (bin >> 4);\n\tbin = (bin + (bin << 5)) ^ MAGIC;\n\tbin = bin ^ (bin >> 11);\n\treturn (normalize((size_t)bin, size));\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "size_t\thash_universal(size_t key, uint64_t a, uint64_t b, uint64_t p,\n\t\tsize_t size)",
                                    "body": "{\n\tsize_t\thash;\n\n\thash = ((a * key + b) % p);\n\treturn (normalize(hash, size));\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "./Utils/Dealloc",
                    "subfolders": [],
                    "files": [
                        {
                            "functions": [
                                {
                                    "doc": "",
                                    "header": "void\tdealloc_int(Generic addr)",
                                    "body": "{\n\tfree((int *)addr);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tdealloc_uint64(Generic addr)",
                                    "body": "{\n\tfree((uint64_t *)addr);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tdealloc_float(Generic addr)",
                                    "body": "{\n\tfree((float *)addr);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tdealloc_string(Generic addr)",
                                    "body": "{\n\tfree((char *)addr);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tdealloc_long(Generic addr)",
                                    "body": "{\n\tfree((long long *)addr);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tdealloc_double(Generic addr)",
                                    "body": "{\n\tfree((double *)addr);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "./Utils/MathUtils",
                    "subfolders": [],
                    "files": [
                        {
                            "functions": []
                        }
                    ]
                }
            ],
            "files": []
        },
        {
            "name": "./DataStructures",
            "subfolders": [
                {
                    "name": "./DataStructures/Stack",
                    "subfolders": [],
                    "files": [
                        {
                            "functions": [
                                {
                                    "doc": "/**\n * @brief adds a value on top of the stack\n *\n * @param stack\n * @param value\n */",
                                    "header": "Stack\tStack_Init(Generic value)",
                                    "body": "{\n\treturn (Stack)(LinkedList_Init(value));\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "/**\n * @brief removes the top value from the stack\n *\n * @param stack\n * @param dealloc\n * @note does not deallocate the value, call Stack_Dealloc_Element\n * @return Generic\n */",
                                    "header": "void\tStack_Add(Stack stack, Generic value)",
                                    "body": "{\n\tLinkedList_Push((LinkedList *)&stack, value);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "/**\n * @brief deallocates the stack element\n *\n * @param stack\n * @param dealloc\n */",
                                    "header": "Generic\tStack_Poll(Stack *stack)",
                                    "body": "{\n\tGeneric\tout;\n\n\tif (!stack)\n\t\treturn (GENERIC_NULL);\n\tout = LinkedList_GetInfo(*stack);\n\t*stack = LinkedList_GetNext(*stack);\n\treturn (out);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tStack_Dealloc_Element(Stack stack, Deallocator dealloc)",
                                    "body": "{\n\tif (!stack)\n\t\treturn ;\n\tif (dealloc)\n\t\tdealloc(stack->info);\n\tfree(stack);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tStack_Free(Stack *stack, void (*dealloc)(Generic))",
                                    "body": "{\n\tLinkedList_Dealloc(*stack, dealloc);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "./DataStructures/Nodes",
                    "subfolders": [],
                    "files": [
                        {
                            "functions": [
                                {
                                    "doc": "",
                                    "header": "Node Node_Init(Generic info)",
                                    "body": "{\n\treturn (Node)NULL;\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "DoubleNode DoubleNode_Init(Generic info)",
                                    "body": "{\n\treturn (Node)malloc(sizeof(Node_));\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "",
                                    "body": "{\n\tNode node = Node_Allocate();\n\tif (!node)\n\t\treturn EmptyNode();\n\tnode->info = info;\n\tnode->next = EmptyNode();\n\treturn node;\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "",
                                    "body": "{\n\tDoubleNode node = (DoubleNode)malloc(sizeof(DoubleNode_));\n\tif (!node)\n\t\treturn (DoubleNode)NULL;\n\tnode->info = info;\n\tnode->next = (DoubleNode)NULL;\n\tnode->prev = (DoubleNode)NULL;\n\treturn node;\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "./DataStructures/Dictionary",
                    "subfolders": [],
                    "files": [
                        {
                            "functions": [
                                {
                                    "doc": "/**\n * @brief Creates Dictionary instance\n *\n * @param size number of buckets, if null size := DEFAULT_SIZE\n * @param cmp function to compare keys\n * @param hash_key function to hash keys\n * @return Dict\n */",
                                    "header": "Dict_obj\tDict_Obj_Init(Generic key, Generic value,\n\t\tDeallocator dealloc_key, Deallocator dealloc_value)",
                                    "body": "{\n\treturn (t_dict)malloc(sizeof(t_dictionary));\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "/**\n * @brief Reallocates dict with double the size\n * @param dict\n */",
                                    "header": "void\tDict_Obj_Dealloc(Generic dict_obj)",
                                    "body": "{\n\tDict_obj\tobj;\n\n\tobj = (Dict_obj)malloc(sizeof(t_dict_obj));\n\tif (!obj)\n\t\treturn (NULL);\n\tobj->key = key;\n\tobj->value = value;\n\tobj->dealloc_key = dealloc_key;\n\tobj->dealloc_value = dealloc_value;\n\treturn (obj);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "/**\n * @brief Add value to dict\\r\n * @attention Key and value <= 8 bytes, use pointers for larger values\n *\n * @param dict\n * @param key value or address\n * @param value value or address\n * @param dealloc_value null if is a value\n * @param cmp function to compare keys\n * @return true if added, false if key already exists\n */",
                                    "header": "t_dict\tDict_Init(size_t size, Comparator cmp, Hasher hash_key,\n\t\tDeallocator dealloc_key)",
                                    "body": "{\n\tDict_obj\tobj;\n\n\tobj = (Dict_obj)dict_obj;\n\tif (obj->dealloc_key)\n\t\tobj->dealloc_key(obj->key);\n\tif (obj->dealloc_value)\n\t\tobj->dealloc_value(obj->value);\n\tfree(dict_obj);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "/**\n * @brief Get value from dict\n *\n * @param dict\n * @param key\n * @param hash_key\n * @param cmp\n * @return void*\n */",
                                    "header": "size_t\thash_function(t_dict dict, size_t hashed_key)",
                                    "body": "{\n\tLinkedList\t*buckets;\n\tsize_t\t\ti;\n\n\tbuckets = (LinkedList *)malloc(sizeof(LinkedList) * size);\n\tif (!buckets)\n\t\treturn (NULL);\n\ti = 0;\n\twhile (i < size)\n\t\tbuckets[i++] = NULL;\n\treturn (buckets);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "/**\n * @brief Remove key and value from dict\n *\n * @param dict\n * @param key\n */",
                                    "header": "LinkedList\ttake_dict_objs(t_dict dict)",
                                    "body": "{\n\tLinkedList\t*buckets;\n\tt_dict\t\tdict;\n\n\tdict = Dict_alloc();\n\tif (!dict)\n\t\treturn (DICT_EMPTY);\n\tdict->size = (!size) ? DEFAULT_SIZE : size;\n\tbuckets = Dict_Alloc_Buckets(dict->size);\n\tif (!buckets)\n\t{\n\t\tfree(dict);\n\t\treturn (DICT_EMPTY);\n\t}\n\tdict->buckets = buckets;\n\tdict->cmp = cmp;\n\tdict->hash_key = hash_key;\n\tdict->used = 0;\n\tdict->dealloc_key = dealloc_key;\n\tdict->prime = PRIME_DEFAULT;\n\tsrandom(time(NULL));\n\tdict->a = 1 + random() / dict->prime;\n\tdict->b = random() / dict->prime;\n\treturn (dict);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "/**\n * @brief Frees all memory used by dict\n *\n * @param dict\n */",
                                    "header": "void\tsoft_add(t_dict dict, Dict_obj obj)",
                                    "body": "{\n\treturn (hash_universal(hashed_key, dict->a, dict->b, dict->prime,\n\t\t\tdict->size));\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "/**\n * @brief Log the status of the dict\n *\n * @param dict\n */",
                                    "header": "void\tDict_Realloc(t_dict dict)",
                                    "body": "{\n\tLinkedList\tlist;\n\tLinkedList\tbucket;\n\tsize_t\t\ti;\n\tDict_obj\tobj;\n\tLinkedList\tnext;\n\n\tlist = LINKEDLIST_EMPTY;\n\ti = 0;\n\twhile (i < dict->size)\n\t{\n\t\tbucket = (dict->buckets)[i];\n\t\twhile (bucket)\n\t\t{\n\t\t\tobj = (Dict_obj)(LinkedList_GetInfo(bucket));\n\t\t\tnext = LinkedList_GetNext(bucket);\n\t\t\tfree(bucket);\n\t\t\tbucket = next;\n\t\t\tLinkedList_Push(&list, obj);\n\t\t}\n\t\ti++;\n\t}\n\treturn (list);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "bool\tdict_has_breached_load_factor(t_dict dict)",
                                    "body": "{\n\tsize_t\t\thash;\n\tLinkedList\tbucket;\n\n\thash = hash_function(dict, dict->hash_key(obj->key, dict->size));\n\tbucket = dict->buckets[hash];\n\tLinkedList_Push(&bucket, obj);\n\tdict->buckets[hash] = bucket;\n\tdict->used++;\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "bool\tDict_Add(t_dict dict, Generic key, Generic value,\n\t\tDeallocator dealloc_value)",
                                    "body": "{\n\tLinkedList\tlist;\n\tLinkedList  temp;\n\n\tlist = take_dict_objs(dict);\n\ttemp = list;\n\tfree(dict->buckets);\n\tdict->buckets = Dict_Alloc_Buckets(dict->size * REALLOC_COEFF);\n\tdict->size = dict->size * REALLOC_COEFF;\n\tdict->used = 0;\n\twhile (list)\n\t{\n\t\tsoft_add(dict, (Dict_obj)LinkedList_GetInfo(list));\n\t\tlist = LinkedList_GetNext(list);\n\t}\n\tLinkedList_Dealloc(temp, NULL);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tDict_Remove(t_dict dict, Generic key)",
                                    "body": "{\n\treturn (((double)(dict->used + 1) / dict->size) >= MAX_LOAD_FACTOR);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tDict_Free(t_dict dict)",
                                    "body": "{\n\tsize_t\t\thash;\n\tLinkedList\t*buckets;\n\tDict_obj\tobj;\n\n\tif (!dict || Dict_Get(dict, key))\n\t\treturn (false);\n\tif (dict_has_breached_load_factor(dict))\n\t\tDict_Realloc(dict);\n\thash = hash_function(dict, dict->hash_key(key, dict->size));\n\tbuckets = dict->buckets;\n\tobj = Dict_Obj_Init(key, value, dict->dealloc_key, dealloc_value);\n\tif (!obj)\n\t\treturn (false);\n\tLinkedList_Push(buckets + hash, obj);\n\tdict->used++;\n\treturn (true);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tDict_Status(t_dict dict)",
                                    "body": "{\n\tconst size_t\thash = hash_function(dict, dict->hash_key(key, dict->size));\n\tLinkedList\t\tbucket;\n\tDict_obj\t\tobj;\n\n\tif (!dict || !dict->used)\n\t\treturn (NULL);\n\tbucket = (dict->buckets)[hash];\n\twhile (LinkedList_GetInfo(bucket)\n\t\t&& dict->cmp(((Dict_obj)LinkedList_GetInfo(bucket))->key, key))\n\t\tbucket = LinkedList_GetNext(bucket);\n\tobj = (Dict_obj)LinkedList_GetInfo(bucket);\n\tif (!obj)\n\t\treturn (NULL);\n\treturn (obj->value);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "",
                                    "body": "{\n\tconst size_t\thash = hash_function(dict, dict->hash_key(key, dict->size));\n\tLinkedList\t\tbucket;\n\n\tbucket = (dict->buckets)[hash];\n\twhile (((Dict_obj)LinkedList_GetInfo(bucket))->key != key)\n\t\tbucket = LinkedList_GetNext(bucket);\n\tLinkedList_Remove(dict->buckets + hash, &Dict_Obj_Dealloc);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "",
                                    "body": "{\n\tsize_t\t\ti;\n\tLinkedList\tbucket;\n\n\ti = 0;\n\twhile (i < dict->size)\n\t{\n\t\tbucket = ((dict->buckets)[i]);\n\t\tLinkedList_Dealloc(bucket, &Dict_Obj_Dealloc);\n\t\ti++;\n\t}\n\tfree(dict->buckets);\n\tfree(dict);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "",
                                    "body": "{\n\tLinkedList\tbucket;\n\n\tprintf(\"Number of buckets used: %zu\\n\", dict->size);\n\tprintf(\"Number of elements: %zu\\n\", dict->used);\n\tprintf(\"Load factor: %f\\n\", (double)dict->used / dict->size);\n\tfor (size_t i = 0; i < dict->size; i++)\n\t{\n\t\tbucket = dict->buckets[i];\n\t\tprintf(\"Bucket %zu: %zu elements\\n\", i, LinkedList_Size(bucket));\n\t}\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "./DataStructures/Graph",
                    "subfolders": [],
                    "files": [
                        {
                            "functions": [
                                {
                                    "doc": "",
                                    "header": "Edge\tEdge_Init(Vertex src, Vertex dest, uint64_t weight)",
                                    "body": "{\n\tEdge\tedge;\n\n\tedge = (Edge)malloc(sizeof(t_edge));\n\tif (!edge)\n\t\treturn (NULL);\n\tedge->src = src;\n\tedge->dest = dest;\n\tedge->weight = weight;\n\treturn (edge);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tEdge_Free(Generic edge)",
                                    "body": "{\n\tfree(edge);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                }
                            ]
                        },
                        {
                            "functions": [
                                {
                                    "doc": "/**\n * @brief BFS\n * @param graph\n * @param src\n * @param target: value of a vertex to find,\n\tif null will explore the whole graph\n */",
                                    "header": "Vertex\tGraph_BFS(Graph graph, Vertex src, Generic target)",
                                    "body": "{\n\tQueue\t\tqueue;\n\tQueue\t\tqueue_el;\n\tVertex\t\tvertex;\n\tVertex\t\tdst;\n\tEdge\t\tedge;\n\tLinkedList\tedges;\n\n\tvertex = NULL;\n\tVertex_InitSingleSource(graph, src);\n\tqueue = Queue_Init(src);\n\twhile ((queue_el = Queue_poll(&queue)))\n\t{\n\t\tvertex = (Vertex)(queue_el->info);\n\t\tedges = vertex->edges;\n\t\twhile (edges)\n\t\t{\n\t\t\tedge = (Edge)LinkedList_GetInfo(edges);\n\t\t\tdst = edge->dest;\n\t\t\tif (dst->status == VERTEX_UNVISITED)\n\t\t\t{\n\t\t\t\tdst->status = VERTEX_VISITING;\n\t\t\t\tdst->distance = vertex->distance + edge->weight;\n\t\t\t\tdst->predecessor = vertex;\n\t\t\t\tQueue_Add(&queue, dst);\n\t\t\t}\n\t\t\tedges = LinkedList_GetNext(edges);\n\t\t}\n\t\tvertex->status = VERTEX_VISITED;\n\t\tQueue_DeallocElement(queue_el, NULL);\n\t\tif (graph->cmp && graph->cmp(vertex->value, target) == 0)\n\t\t\tbreak ;\n\t}\n\tQueue_Dealloc(&queue, NULL);\n\treturn (vertex);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "/**\n * @brief DFS\n * @param graph\n */",
                                    "header": "void\tDFS_Visit(Vertex vertex, uint64_t *time)",
                                    "body": "{\n\tLinkedList\tedges;\n\tVertex\t\tneighbor;\n\n\tvertex->discovery_time = *time++;\n\tvertex->status = VERTEX_VISITING;\n\tedges = vertex->edges;\n\twhile (edges)\n\t{\n\t\tneighbor = ((Edge)LinkedList_GetInfo(edges))->dest;\n\t\tif (neighbor->status == VERTEX_UNVISITED)\n\t\t\tDFS_Visit(neighbor, time);\n\t\tedges = LinkedList_GetNext(edges);\n\t}\n\tprintf(\"ended vertex %s\\n\", (char *)vertex->value);\n\tvertex->status = VERTEX_VISITED;\n\tvertex->finish_time = *time++;\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "Vertex\tGraph_DFS(Graph graph)",
                                    "body": "{\n\tLinkedList\tvertices;\n\tVertex\t\tvertex;\n\tuint64_t\ttime;\n\n\ttime = 0;\n\tvertices = graph->adjacency_list;\n\tVertex_InitSingleSource(graph, NULL);\n\twhile (vertices)\n\t{\n\t\tvertex = LinkedList_GetInfo(vertices);\n\t\tif (vertex->status == VERTEX_UNVISITED)\n\t\t\tDFS_Visit(vertex, &time);\n\t\tvertices = LinkedList_GetNext(vertices);\n\t}\n\treturn (NULL);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                }
                            ]
                        },
                        {
                            "functions": [
                                {
                                    "doc": "/**\n * @brief Generate a mermaid file from a graph\n * @param graph\n * @param filename (generate or replace)\n * @param direction (MERMAID_VERTICAL or MERMAID_HORIZONAL)\n */",
                                    "header": "void\tGraph_GenerateMermaid(Graph graph, String filename, String direction)",
                                    "body": "{\n\tFILE\t\t*file;\n\tLinkedList\tvertices;\n\tVertex\t\tvertex;\n\tLinkedList\tedges;\n\tEdge\t\tedge;\n\n\tfile = fopen(filename, \"w\");\n\tif (!file)\n\t\treturn ;\n\tfprintf(file, \"```mermaid\\nflowchart %s\\n\",\n\t\t(direction) ? direction : MERMAID_HORIZONAL);\n\tvertices = graph->adjacency_list;\n\twhile (vertices)\n\t{\n\t\tvertex = (Vertex)LinkedList_GetInfo(vertices);\n\t\tedges = vertex->edges;\n\t\tif (!edges)\n\t\t\tfprintf(file, \"%zu((%s))\\n\", vertex->id, (String)vertex->value);\n\t\telse\n\t\t{\n\t\t\twhile (edges)\n\t\t\t{\n\t\t\t\tedge = (Edge)LinkedList_GetInfo(edges);\n\t\t\t\tfprintf(file, \"%zu((%s)) -- %zu --> %zu((%s))\\n\", edge->src->id,\n\t\t\t\t\t(String)edge->src->value, edge->weight, edge->dest->id,\n\t\t\t\t\t(String)edge->dest->value);\n\t\t\t\tedges = LinkedList_GetNext(edges);\n\t\t\t}\n\t\t}\n\t\tvertices = LinkedList_GetNext(vertices);\n\t}\n\tfprintf(file, \"```\\n\");\n\tfclose(file);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                }
                            ]
                        },
                        {
                            "functions": [
                                {
                                    "doc": "/**\n * @brief Dijkstra's algorithm to find the shortest path in a graph.\n * @note min_heap_entry: {distance: uint64_t, vertex: Vertex}\n */",
                                    "header": "void\tDijkstra_Init_MinHeap_Hashmap(t_heap min_heap, LinkedList vertices,\n\t\tt_dict hashmap)",
                                    "body": "{\n\tuint64_t\t\t*dist;\n\tt_heap_entry\tentry;\n\tVertex\t\t\tvertex;\n\n\tif (!min_heap || !vertices || !hashmap)\n\t\treturn ;\n\twhile (vertices)\n\t{\n\t\tvertex = LinkedList_GetInfo(vertices);\n\t\tdist = (uint64_t *)malloc(sizeof(uint64_t));\n\t\t*dist = vertex->distance;\n\t\tentry = HeapEntry_Init(dist, vertex);\n\t\tHeap_Insert(min_heap, entry);\n\t\tDict_Add(&hashmap, vertex, entry, NULL, NULL);\n\t\tvertices = LinkedList_GetNext(vertices);\n\t}\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "LinkedList\tDijkstra(Graph graph, Vertex src, Vertex dest)",
                                    "body": "{distance: uint64_t, vertex: Vertex}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "",
                                    "body": "{\n\tLinkedList\t\tpath;\n\tt_heap\t\t\tmin_heap;\n\tt_dict\t\t\thashmap;\n\tLinkedList\t\tvertices;\n\tVertex\t\t\tvertex;\n\tLinkedList\t\tvertex_edges;\n\tEdge\t\t\tedge;\n\tuint64_t\t\t*weight_ref;\n\tt_heap_entry\tentry;\n\tt_heap_entry\tentry_from_dict;\n\tLinkedList\t\tvisited_entries;\n\n\tpath = NULL;\n\tvisited_entries = NULL;\n\tif (!graph || !src || !dest)\n\t\treturn (NULL);\n\tvertices = graph->adjacency_list;\n\thashmap = Dict_Init(LinkedList_Size(vertices), Vertex_CmpId, Vertex_Hash);\n\tif (!hashmap)\n\t\treturn (NULL);\n\tmin_heap = Heap_Init(LinkedList_Size(vertices), Vertex_CmpDistance,\n\t\t\tDijkstraHeapEntry_Free, true);\n\tif (!min_heap)\n\t{\n\t\tDict_Free(hashmap);\n\t\treturn (NULL);\n\t}\n\tVertex_InitSingleSource(graph, src);\n\tDijkstra_Init_MinHeap_Hashmap(min_heap, vertices, hashmap);\n\twhile ((entry = Heap_PollMin(min_heap)))\n\t{\n\t\tvertex = (Vertex)entry->value;\n\t\tvertex_edges = vertex->edges;\n\t\twhile ((edge = (Edge)LinkedList_GetInfo(vertex_edges)))\n\t\t{\n\t\t\tentry_from_dict = ((t_heap_entry)Dict_Get(hashmap, edge->dest));\n\t\t\tif (Edge_Relax(vertex, edge->dest, edge->weight))\n\t\t\t{\n\t\t\t\tweight_ref = (uint64_t *)(entry_from_dict->key);\n\t\t\t\t*weight_ref = edge->dest->distance;\n\t\t\t}\n\t\t\tvertex_edges = LinkedList_GetNext(vertex_edges);\n\t\t}\n\t\tLinkedList_Push(&visited_entries, entry);\n\t}\n\tpath = BuildPath(dest);\n\tLinkedList_Dealloc(visited_entries, DijkstraHeapEntry_Free);\n\tDict_Free(hashmap);\n\tHeap_Free(min_heap);\n\treturn (path);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                }
                            ]
                        },
                        {
                            "functions": [
                                {
                                    "doc": "",
                                    "header": "Graph\tGraph_Init(void (*dealloc_vertex)(Generic), int (*cmp)",
                                    "body": "{\n\tGraph\tgraph;\n\n\tgraph = (Graph)malloc(sizeof(t_graph));\n\tif (!graph)\n\t\treturn (NULL);\n\tgraph->adjacency_list = LINKEDLIST_EMPTY;\n\tgraph->cmp = cmp;\n\tgraph->dealloc_vertex = dealloc_vertex;\n\treturn (graph);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tGraph_Free(Graph graph)",
                                    "body": "{\n\tLinkedList\tadj_list;\n\tVertex\t\tvertex;\n\n\tif (!graph)\n\t\treturn ;\n\tadj_list = graph->adjacency_list;\n\twhile (adj_list)\n\t{\n\t\tvertex = (Vertex)adj_list->info;\n\t\tVertex_Free(graph, vertex);\n\t\tadj_list = adj_list->next;\n\t}\n\tLinkedList_Dealloc(graph->adjacency_list, NULL);\n\tfree(graph);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tGraph_AddVertex(Graph graph, Vertex vertex)",
                                    "body": "{\n\tLinkedList_Push(&graph->adjacency_list, vertex);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tGraph_AddEdge(Vertex vertex, Edge edge)",
                                    "body": "{\n\tLinkedList_Push(&vertex->edges, edge);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tGraph_AddDoubleEdge(Vertex vertex, Edge edge)",
                                    "body": "{\n\tEdge\tdouble_edge;\n\n\tdouble_edge = Edge_Init(edge->dest, edge->src, edge->weight);\n\tGraph_AddEdge(vertex, edge);\n\tGraph_AddEdge(edge->dest, double_edge);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tGraph_RemoveVertex(Graph graph, Vertex vertex)",
                                    "body": "{\n\tLinkedList\tadj_list;\n\tVertex\t\tv;\n\n\tadj_list = graph->adjacency_list;\n\twhile (adj_list)\n\t{\n\t\tv = (Vertex)adj_list->info;\n\t\tif (v->id == vertex->id)\n\t\t{\n\t\t\tVertex_Free(graph, v);\n\t\t\tLinkedList_Remove(&graph->adjacency_list, NULL);\n\t\t\treturn ;\n\t\t}\n\t\tadj_list = adj_list->next;\n\t}\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tGraph_RemoveEdge(Vertex vertex, Edge edge)",
                                    "body": "{\n\tLinkedList\tedges;\n\tEdge\t\te;\n\n\tedges = vertex->edges;\n\twhile (edges)\n\t{\n\t\te = (Edge)edges->info;\n\t\tif (e->dest->id == edge->dest->id)\n\t\t{\n\t\t\tLinkedList_Remove(&vertex->edges, Edge_Free);\n\t\t\treturn ;\n\t\t}\n\t\tedges = edges->next;\n\t}\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tGraph_RemoveDoubleEdge(Vertex vertex, Edge edge)",
                                    "body": "{\n\tGraph_RemoveEdge(vertex, edge);\n\t// check if other edge exists\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                }
                            ]
                        },
                        {
                            "functions": [
                                {
                                    "doc": "",
                                    "header": "Vertex\tVertex_Init(Generic value)",
                                    "body": "{\n\tstatic uint32_t\tid = 0;\n\tVertex\t\t\tvertex;\n\n\tvertex = (Vertex)malloc(sizeof(t_vertex));\n\tif (!vertex)\n\t\treturn (NULL);\n\tvertex->edges = LINKEDLIST_EMPTY;\n\tvertex->value = value;\n\tvertex->id = id++;\n\tvertex->status = VERTEX_UNVISITED;\n\tvertex->distance = 0;\n\tvertex->discovery_time = 0;\n\tvertex->finish_time = 0;\n\tvertex->predecessor = NULL;\n\treturn (vertex);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tVertex_Free(Graph graph, Vertex vertex)",
                                    "body": "{\n\tLinkedList_Dealloc(vertex->edges, Edge_Free);\n\tif (graph->dealloc_vertex)\n\t\tgraph->dealloc_vertex(vertex->value);\n\tfree(vertex);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                }
                            ]
                        },
                        {
                            "functions": [
                                {
                                    "doc": "",
                                    "header": "void\tVertex_InitSingleSource(Graph graph, Vertex src)",
                                    "body": "{\n\tLinkedList\tvertices;\n\tVertex\t\tvertex;\n\n\tif (!graph)\n\t\treturn ;\n\tvertices = graph->adjacency_list;\n\twhile (vertices)\n\t{\n\t\tvertex = (Vertex)(vertices->info);\n\t\tvertex->distance = UINT64_MAX;\n\t\tvertex->discovery_time = 0;\n\t\tvertex->finish_time = 0;\n\t\tvertex->status = VERTEX_UNVISITED;\n\t\tvertex->predecessor = NULL;\n\t\tvertices = LinkedList_GetNext(vertices);\n\t}\n\tif (!src)\n\t\treturn ;\n\tsrc->distance = 0;\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "bool\tEdge_Relax(Vertex src, Vertex dest, uint64_t weight)",
                                    "body": "{\n\tif (dest->distance <= src->distance + weight)\n\t\treturn (false);\n\tdest->distance = src->distance + weight;\n\tdest->predecessor = src;\n\treturn (true);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "int\tVertex_CmpDistance(Generic a, Generic b)",
                                    "body": "{\n\tuint64_t\t*dist_a;\n\tuint64_t\t*dist_b;\n\n\tdist_a = (uint64_t *)((t_heap_entry)a)->key;\n\tdist_b = (uint64_t *)((t_heap_entry)b)->key;\n\tif (*dist_a < *dist_b)\n\t\treturn (-1);\n\tif (*dist_a > *dist_b)\n\t\treturn (1);\n\treturn (0);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "int\tVertex_CmpId(Generic a, Generic b)",
                                    "body": "{\n\treturn ((int)((Vertex)a)->id - (int)((Vertex)b)->id);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tDijkstraHeapEntry_Free(Generic entry)",
                                    "body": "{\n\tt_heap_entry\te;\n\n\te = (t_heap_entry)entry;\n\tdealloc_uint64(e->key);\n\tfree(e);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "size_t\tVertex_Hash(Generic vertex, size_t capacity)",
                                    "body": "{\n\treturn (((size_t)((Vertex)vertex)->id) % capacity);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "LinkedList\tBuildPath(Vertex dest)",
                                    "body": "{\n\tLinkedList\tpath;\n\n\tpath = NULL;\n\twhile (dest)\n\t{\n\t\tLinkedList_Push(&path, dest);\n\t\tdest = dest->predecessor;\n\t}\n\treturn (path);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "./DataStructures/Tree",
                    "subfolders": [],
                    "files": [
                        {
                            "functions": [
                                {
                                    "doc": "",
                                    "header": "BST\tBst_Init(Generic key, Generic info, Comparator cmp)",
                                    "body": "{\n\tBST\tbst;\n\n\tbst = (BST)malloc(sizeof(Bst));\n\tif (!bst)\n\t\treturn (NULL);\n\tbst->root = BinaryTree_Init(info, BINARY_TREE_EMPTY, BINARY_TREE_EMPTY);\n\tbst->cmp = cmp;\n\treturn (bst);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "Generic\tBst_Insert(Generic key, Generic info);\nvoid\tBst_Remove(Generic key);\nvoid\tBst_Free(BST node)",
                                    "body": "",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                }
                            ]
                        },
                        {
                            "functions": [
                                {
                                    "doc": "",
                                    "header": "bool\tTreeIsEmpty(BinaryTree tree)",
                                    "body": "{\n\treturn (tree == NULL);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "BinaryTree\tBinaryTree_Init(Generic info, BinaryTree left, BinaryTree right)",
                                    "body": "{\n\treturn (BinaryTree)malloc(sizeof(BinaryTreeNode));\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "BinaryTree\tBinaryTree_Left(BinaryTree tree)",
                                    "body": "{\n\tBinaryTree\ttree;\n\n\ttree = InitTreeNode();\n\tif (!tree)\n\t\treturn (BINARY_TREE_EMPTY);\n\ttree->info = info;\n\ttree->key = NULL;\n\ttree->left = left;\n\ttree->right = right;\n\treturn (tree);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "BinaryTree\tBinaryTree_Right(BinaryTree tree)",
                                    "body": "{\n\tif (tree)\n\t\treturn (tree->left);\n\treturn (BINARY_TREE_EMPTY);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "size_t\tBinaryTree_Depth(BinaryTree tree)",
                                    "body": "{\n\tif (tree)\n\t\treturn (tree->right);\n\treturn (BINARY_TREE_EMPTY);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "size_t\tBinaryTree_MaxNodesNumber(size_t depth)",
                                    "body": "{\n\tsize_t\tleft;\n\tsize_t\tright;\n\n\tif (TreeIsEmpty(tree))\n\t\treturn (0);\n\tleft = BinaryTree_Depth(BinaryTree_Left(tree));\n\tright = BinaryTree_Depth(BinaryTree_Right(tree));\n\treturn (1 + ((left > right) ? left : right));\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "Generic\tBinaryTree_Value(BinaryTree tree)",
                                    "body": "{\n\treturn ((size_t)pow(2, depth) - 1);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tBinaryTree_SetLeft(BinaryTree tree, BinaryTree left)",
                                    "body": "{\n\tif (tree)\n\t\treturn (tree->info);\n\treturn (NULL);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tBinaryTree_SetDeepLeft(BinaryTree *tree, BinaryTree left)",
                                    "body": "{\n\tif (!TreeIsEmpty(tree) && !TreeIsEmpty(left))\n\t\ttree->left = left;\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "bool\tIsLeaf(BinaryTree tree)",
                                    "body": "{\n\tif (TreeIsEmpty(*tree))\n\t\t*tree = left;\n\telse\n\t\tBinaryTree_SetDeepLeft(&((*tree)->left), left);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "bool\tHasTwoNodes(BinaryTree tree)",
                                    "body": "{\n\treturn (TreeIsEmpty(BinaryTree_Left(tree))\n\t\t&& TreeIsEmpty(BinaryTree_Right(tree)));\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "bool\tBinaryTree_DeleteTreeNode(BinaryTree *tree, Generic value)",
                                    "body": "{\n\treturn (!TreeIsEmpty(BinaryTree_Left(tree))\n\t\t&& !TreeIsEmpty(BinaryTree_Right(tree)));\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tBinaryTree_Free(BinaryTree tree)",
                                    "body": "{\n\tBinaryTree\tright;\n\tBinaryTree\ttemp;\n\n\tif (TreeIsEmpty(*tree))\n\t\treturn (false);\n\tif (BinaryTree_Value(*tree) == value)\n\t{\n\t\tright = BinaryTree_Right(*tree);\n\t\tif (!TreeIsEmpty(right))\n\t\t\tBinaryTree_SetDeepLeft(tree, right);\n\t\ttemp = *tree;\n\t\t*tree = BinaryTree_Left(*tree);\n\t\tfree(temp);\n\t\treturn (true);\n\t}\n\telse\n\t\treturn (BinaryTree_DeleteTreeNode(&((*tree)->left), value)\n\t\t\t|| BinaryTree_DeleteTreeNode(&((*tree)->right), value));\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "",
                                    "body": "{\n\tif (!tree)\n\t\treturn ;\n\t\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "./DataStructures/PriorityQueue",
                    "subfolders": [],
                    "files": [
                        {
                            "functions": []
                        }
                    ]
                },
                {
                    "name": "./DataStructures/Heap",
                    "subfolders": [],
                    "files": [
                        {
                            "functions": [
                                {
                                    "doc": "/**\n * @brief Create a new heap entry.\n * @param capacity: the capacity of the heap\n * @param cmp: function to compare the keys of the heap entries\n * @param dealloc: function to deallocate the entry of the heap (key + value\n\t+ entry itself)\n * @param is_min_heap: if the heap is a min heap\n */",
                                    "header": "t_heap\tHeap_Init(size_t capacity, Comparator cmp, Deallocator dealloc,\n\t\tbool is_min_heap)",
                                    "body": "{\n\tt_heap\theap;\n\n\theap = malloc(sizeof(t_heap_));\n\tif (!heap)\n\t\treturn (NULL);\n\theap->entries = malloc(sizeof(t_heap_entry) * capacity);\n\tif (!heap->entries)\n\t{\n\t\tfree(heap);\n\t\treturn (NULL);\n\t}\n\theap->length = 0;\n\theap->capacity = capacity;\n\theap->cmp = cmp;\n\theap->dealloc = dealloc;\n\theap->is_min_heap = is_min_heap;\n\treturn (heap);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "/**\n * @brief Free the heap\n */",
                                    "header": "void\tHeap_Free(t_heap heap)",
                                    "body": "{\n\tsize_t\t\t\ti;\n\tt_heap_entry\t*entries;\n\tDeallocator\t\tdealloc;\n\n\tif (!heap)\n\t\treturn ;\n\ti = 0;\n\tentries = heap->entries;\n\tdealloc = heap->dealloc;\n\twhile (i < heap->length)\n\t{\n\t\tdealloc(entries[i]);\n\t\ti++;\n\t}\n\tfree(heap->entries);\n\tfree(heap);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "/**\n * @brief swap entrie values\n */",
                                    "header": "void\tswap_entries(t_heap_entry a, t_heap_entry b)",
                                    "body": "{\n\tGeneric\tkey;\n\tGeneric\tvalue;\n\n\tif (!a || !b)\n\t\treturn ;\n\tkey = a->key;\n\tvalue = a->value;\n\ta->key = b->key;\n\ta->value = b->value;\n\tb->key = key;\n\tb->value = value;\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "/**\n * @brief gets null terminated array length\n */",
                                    "header": "size_t\tlimit_arr(t_heap_entry *arr, size_t expected_lenth)",
                                    "body": "{\n\tsize_t\ti;\n\n\tif (!arr || !expected_lenth)\n\t\treturn (0);\n\ti = 0;\n\twhile (i < expected_lenth && arr[i])\n\t\ti++;\n\treturn (i);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "/**\n * @brief Heapify the heap at index i\n */",
                                    "header": "void\tHeap_Heapify(t_heap heap, size_t index)",
                                    "body": "{\n\tt_heap_entry\ttemp[3];\n\tt_heap_entry\tswap;\n\tsize_t\t\t\tmax_length;\n\n\tif (!heap || !heap->length)\n\t\treturn ;\n\ttemp[0] = heap->entries[index];\n\ttemp[1] = HeapEntry_GetLeftChild(heap, index);\n\ttemp[2] = HeapEntry_GetRightChild(heap, index);\n\tmax_length = limit_arr(temp, 3);\n\tif (!max_length)\n\t\treturn ;\n\tMergeSort((Generic *)temp, max_length, heap->cmp);\n\tif (heap->is_min_heap)\n\t\tswap = temp[0];\n\telse\n\t\tswap = temp[max_length - 1];\n\tif (swap->index == index)\n\t\treturn ;\n\tswap_entries(heap->entries[index], swap);\n\tHeap_Heapify(heap, swap->index);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "/**\n * @brief Build the heap from a generic array\n */",
                                    "header": "void\tHeap_Build(t_heap heap)",
                                    "body": "{\n\tsize_t\ti;\n\n\ti = heap->length / 2;\n\twhile (i > 0)\n\t{\n\t\tHeap_Heapify(heap, i);\n\t\ti--;\n\t}\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "/**\n * @brief get min\n * @return actual value\n */",
                                    "header": "Generic\tHeap_GetMin(t_heap heap)",
                                    "body": "{\n\tif (!heap || !heap->is_min_heap)\n\t\treturn (NULL);\n\tif (heap->length == 0)\n\t\treturn (NULL);\n\treturn (heap->entries[0]->value);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "/**\n * @brief get max\n * @return actual value\n */",
                                    "header": "Generic\tHeap_GetMax(t_heap heap)",
                                    "body": "{\n\tif (!heap || heap->is_min_heap)\n\t\treturn (NULL);\n\tif (heap->length == 0)\n\t\treturn (NULL);\n\treturn (heap->entries[0]->value);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "/**\n * @brief Poll the min value from the heap\n * @return the heap entry containing the min value\n */",
                                    "header": "t_heap_entry\tHeap_PollMin(t_heap heap)",
                                    "body": "{\n\tt_heap_entry\tmin;\n\n\tif (!heap || !heap->is_min_heap || !heap->length)\n\t\treturn (NULL);\n\tmin = heap->entries[0];\n\theap->entries[0] = heap->entries[heap->length - 1];\n\theap->length--;\n\tHeap_Heapify(heap, 0);\n\treturn (min);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "/**\n * @brief Poll the max value from the heap\n * @return the heap entry containing the max value\n */",
                                    "header": "t_heap_entry\tHeap_PollMax(t_heap heap)",
                                    "body": "{\n\tt_heap_entry\tmax;\n\n\tif (!heap || heap->is_min_heap || !heap->length)\n\t\treturn (NULL);\n\tmax = heap->entries[0];\n\theap->entries[0] = heap->entries[heap->length - 1];\n\theap->length--;\n\tHeap_Heapify(heap, 0);\n\treturn (max);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "/**\n * @brief Increase the key of the heap at index\n */",
                                    "header": "void\tHeap_Increase(t_heap heap, size_t index)",
                                    "body": "{\n\tt_heap_entry\tparent;\n\n\tif (!heap)\n\t\treturn ;\n\twhile (index && (parent = HeapEntry_GetParent(heap, index))\n\t\t&& heap->cmp(parent, heap->entries[index]) < 0)\n\t{\n\t\tswap_entries(heap->entries[index], parent);\n\t\tindex = ENTRY_PARENT(index);\n\t}\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "/**\n * @brief Decrease the key of the heap at index\n */",
                                    "header": "void\tHeap_Decrease(t_heap heap, size_t index)",
                                    "body": "{\n\tt_heap_entry\tparent;\n\n\tif (!heap)\n\t\treturn ;\n\twhile (index && (parent = HeapEntry_GetParent(heap, index))\n\t\t&& heap->cmp(parent, heap->entries[index]) > 0)\n\t{\n\t\tswap_entries(heap->entries[index], parent);\n\t\tindex = ENTRY_PARENT(index);\n\t}\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "/**\n * @brief Insert a new entry in the heap\n */",
                                    "header": "void\tHeap_Insert(t_heap heap, t_heap_entry entry)",
                                    "body": "{\n\tif (!heap || !entry || !entry->key)\n\t\treturn ;\n\tif (heap->length == heap->capacity)\n\t\treturn ;\n\tentry->index = heap->length;\n\theap->entries[heap->length] = entry;\n\theap->length++;\n\tif (heap->is_min_heap)\n\t\tHeap_Decrease(heap, heap->length - 1);\n\telse\n\t\tHeap_Increase(heap, heap->length - 1);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "/**\n * @brief Replace the key of the entry in the heap\n */",
                                    "header": "void\tHeap_ReplaceKey(t_heap heap, t_heap_entry entry, Generic key,\n\t\tDeallocator dealloc)",
                                    "body": "{\n\tvoid\t(*func)(t_heap, size_t);\n\n\tif (!heap || !entry || !key)\n\t\treturn ;\n\tfunc = (heap->is_min_heap) ? Heap_Decrease : Heap_Increase;\n\tif (dealloc)\n\t\tdealloc(entry->key);\n\tentry->key = key;\n\tfunc(heap, entry->index);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                }
                            ]
                        },
                        {
                            "functions": [
                                {
                                    "doc": "/**\n * @brief Create a new heap entry.\n * @param key: the key of the entry\n * @param value: the value of the entry\n */",
                                    "header": "t_heap_entry\tHeapEntry_Init(Generic key, Generic value)",
                                    "body": "{\n\tt_heap_entry\tentry;\n\n\tentry = malloc(sizeof(t_heap_entry_));\n\tif (!entry)\n\t\treturn (NULL);\n\tentry->key = key;\n\tentry->value = value;\n\tentry->index = 0;\n\treturn (entry);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "/**\n * @return the left child of the entry at index i (null if out of bounds)\n */",
                                    "header": "t_heap_entry\tHeapEntry_GetLeftChild(t_heap heap, size_t i)",
                                    "body": "{\n\tsize_t\tleft_child_index;\n\n\tleft_child_index = ENTRY_LEFT(i);\n\tif (left_child_index >= heap->length)\n\t\treturn (NULL);\n\treturn (heap->entries[left_child_index]);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "/**\n * @return the right child of the entry at index i (null if out of bounds)\n */",
                                    "header": "t_heap_entry\tHeapEntry_GetRightChild(t_heap heap, size_t i)",
                                    "body": "{\n\tsize_t\tright_child_index;\n\n\tright_child_index = ENTRY_RIGHT(i);\n\tif (right_child_index >= heap->length)\n\t\treturn (NULL);\n\treturn (heap->entries[right_child_index]);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "/**\n * @return the parent child of the entry at index i (null if out of bounds)\n */",
                                    "header": "t_heap_entry\tHeapEntry_GetParent(t_heap heap, size_t i)",
                                    "body": "{\n\tif (!i)\n\t\treturn (NULL);\n\treturn (heap->entries[ENTRY_PARENT(i)]);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "./DataStructures/Queue",
                    "subfolders": [],
                    "files": [
                        {
                            "functions": [
                                {
                                    "doc": "/**\n * @brief Poll the first element of the queue\n * @param queue: the queue\n * @note element is not deallocated, call Queue_DeallocElement\n * @return the first element of the queue\n */",
                                    "header": "Queue\tQueue_Init(Generic info)",
                                    "body": "{\n\treturn (Queue)LinkedList_Init(info);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "/**\n * @brief Deallocate the element of the queue\n * @param queue: the queue\n * @param dealloc: the deallocator function\n * @note use only if poll is called (dealloc poll returned value)\n */",
                                    "header": "void\tQueue_Add(Queue *queue, Generic info)",
                                    "body": "{\n\tLinkedList_Append(queue, info);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "Queue\tQueue_poll(Queue *queue)",
                                    "body": "{\n\tQueue\tout;\n\n\tif (!queue || !*queue)\n\t\treturn (GENERIC_NULL);\n\tout = *queue;\n\t*queue = (*queue)->next;\n\treturn (out);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tQueue_DeallocElement(Queue queue, Deallocator dealloc)",
                                    "body": "{\n\tif (!queue)\n\t\treturn ;\n\tif (dealloc)\n\t\tdealloc(queue->info);\n\tfree(queue);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tQueue_Dealloc(Queue *queue, Deallocator dealloc)",
                                    "body": "{\n\tLinkedList_Dealloc(*queue, dealloc);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "./DataStructures/LinkedList",
                    "subfolders": [],
                    "files": [
                        {
                            "functions": [
                                {
                                    "doc": "",
                                    "header": "DoubleLinkedList\tDoubleLinkedList_Init(Generic info)",
                                    "body": "{\n\treturn (DoubleNode_Init(info));\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "DoubleLinkedList\tDoubleLinkedList_Insert(DoubleLinkedList *list,\n\t\tGeneric info, size_t index)",
                                    "body": "{\n\tDoubleLinkedList\ttemp;\n\tDoubleLinkedList\tnode;\n\tDoubleLinkedList\tprev;\n\n\tif (!list || !*list || !info)\n\t\treturn (DOUBLELINKEDLIST_EMPTY);\n\tif (index == START)\n\t\treturn (DoubleLinkedList_Push(list, info));\n\tif (index == LAST)\n\t\treturn (DoubleLinkedList_Append(*list, info));\n\ttemp = DoubleLinkedList_GetNth(*list, index);\n\tnode = DoubleNode_Init(info);\n\tif (temp)\n\t\ttemp->prev = node;\n\tnode->next = temp;\n\tprev = node->prev;\n\tnode->prev = prev;\n\tif (prev)\n\t\tprev->next = node;\n\treturn (node);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "DoubleLinkedList\tDoubleLinkedList_Append(DoubleLinkedList list, Generic info)",
                                    "body": "{\n\tDoubleLinkedList\tlast;\n\n\tlast = DoubleLinkedList_GetLast(list);\n\tlast->next = DoubleLinkedList_Init(info);\n\tlast->next->prev = last;\n\treturn (last->next);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "DoubleLinkedList\tDoubleLinkedList_Push(DoubleLinkedList *list, Generic info)",
                                    "body": "{\n\tDoubleLinkedList\tnode;\n\n\tnode = DoubleLinkedList_Init(info);\n\tnode->next = *list;\n\t*list = node;\n\treturn (node);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tDoubleLinkedList_Remove(DoubleLinkedList node, Deallocator dealloc)",
                                    "body": "{\n\tDoubleLinkedList\tnext;\n\tDoubleLinkedList\tprev;\n\n\tif (!node)\n\t\treturn ;\n\tnext = (node)->next;\n\tprev = (node)->prev;\n\tif (prev)\n\t\tprev->next = next;\n\tif (next)\n\t\tnext->prev = prev;\n\tif (dealloc)\n\t\tdealloc(node->info);\n\tfree(node);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tDoubleLinkedList_RemoveByValue(DoubleLinkedList list, Comparator cmp,\n\t\tGeneric info, Deallocator dealloc)",
                                    "body": "{\n\tDoubleLinkedList\tnode;\n\n\tnode = DoubleLinkedList_Search(list, cmp, info);\n\tDoubleLinkedList_Remove(node, dealloc);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tDoubleLinkedList_RemoveByIndex(DoubleLinkedList list, size_t index,\n\t\tDeallocator dealloc)",
                                    "body": "{\n\tDoubleLinkedList_Remove(DoubleLinkedList_GetNth(list, index), dealloc);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "DoubleLinkedList\tDoubleLinkedList_Search(DoubleLinkedList list,\n\t\tComparator cmp, Generic info)",
                                    "body": "{\n\twhile (list && cmp(DoubleLinkedList_GetInfo(list), info))\n\t\tlist = DoubleLinkedList_GetNext(list);\n\treturn (list);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "DoubleLinkedList\tDoubleLinkedList_GetNth(DoubleLinkedList list, size_t index)",
                                    "body": "{\n\tsize_t\ti;\n\n\ti = 0;\n\twhile (list && i < index)\n\t{\n\t\tlist = DoubleLinkedList_GetNext(list);\n\t\ti++;\n\t}\n\treturn (list);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "DoubleLinkedList\tDoubleLinkedList_GetFirst(DoubleLinkedList list)",
                                    "body": "{\n\tif (!list)\n\t\treturn (DOUBLELINKEDLIST_EMPTY);\n\treturn (list);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "DoubleLinkedList\tDoubleLinkedList_GetLast(DoubleLinkedList list)",
                                    "body": "{\n\tif (!list)\n\t\treturn (DOUBLELINKEDLIST_EMPTY);\n\twhile (list->next)\n\t\tlist = list->next;\n\treturn (list);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "DoubleLinkedList\tDoubleLinkedList_GetNext(DoubleLinkedList list)",
                                    "body": "{\n\tif (!list)\n\t\treturn (DOUBLELINKEDLIST_EMPTY);\n\treturn (list->next);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "DoubleLinkedList\tDoubleLinkedList_GetPrev(DoubleLinkedList list)",
                                    "body": "{\n\tif (!list)\n\t\treturn (DOUBLELINKEDLIST_EMPTY);\n\treturn (list->prev);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "DoubleLinkedList\tDoubleLinkedList_GetInfo(DoubleLinkedList list)",
                                    "body": "{\n\tif (!list)\n\t\treturn (DOUBLELINKEDLIST_EMPTY);\n\treturn (list->next);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "size_t\tDoubleLinkedList_GetLength(DoubleLinkedList list)",
                                    "body": "{\n\tsize_t\tlength;\n\n\tlength = 0;\n\twhile (list)\n\t{\n\t\tlist = list->next;\n\t\tlength++;\n\t}\n\treturn (length);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tDoubleLinkedList_Dealloc(DoubleLinkedList list, Deallocator dealloc)",
                                    "body": "{\n\tDoubleLinkedList\tnext;\n\n\twhile (list)\n\t{\n\t\tnext = list->next;\n\t\tif (dealloc)\n\t\t\tdealloc(list->info);\n\t\tfree(list);\n\t\tlist = next;\n\t}\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                }
                            ]
                        },
                        {
                            "functions": [
                                {
                                    "doc": "",
                                    "header": "LinkedList\tLinkedList_Init(Generic value)",
                                    "body": "{\n\treturn (LinkedList)malloc(sizeof(Node_));\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tLinkedList_Push(LinkedList *list, Generic object)",
                                    "body": "{\n\tLinkedList\tlist;\n\n\tlist = LinkedList_Alloc();\n\tif (!list)\n\t\treturn (LINKEDLIST_EMPTY);\n\tlist->info = value;\n\tlist->next = LINKEDLIST_EMPTY;\n\treturn (list);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "LinkedList\tLinkedList_Append(LinkedList *list, Generic value)",
                                    "body": "{\n\tLinkedList\tnode;\n\n\tnode = LinkedList_Init(object);\n\tnode->next = *list;\n\t*list = node;\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tLinkedList_Remove(LinkedList *node, Deallocator dealloc)",
                                    "body": "{\n\tLinkedList\tnode;\n\tLinkedList\tlast;\n\n\tif (!list)\n\t\treturn (LINKEDLIST_EMPTY);\n\tnode = LinkedList_Init(value);\n\tlast = LinkedList_GetLast(*list);\n\tif (!last)\n\t\t*list = node;\n\telse\n\t\tlast->next = node;\n\treturn (node);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tLinkedList_RemoveByValue(LinkedList *list, Generic value,\n\t\tDeallocator dealloc, int (*cmp)",
                                    "body": "{\n\tLinkedList\ttmp;\n\n\tif (!node || !*node)\n\t\treturn ;\n\ttmp = *node;\n\t*node = (*node)->next;\n\tif (dealloc)\n\t\tdealloc(tmp->info);\n\tfree(tmp);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "LinkedList\tLinkedList_GetNode(LinkedList list, Generic value)",
                                    "body": "{\n\tif (!list || !*list || !value)\n\t\treturn ;\n\twhile (*list && cmp(LinkedList_GetInfo(*list), value) != 0)\n\t\tlist = &((*list)->next);\n\tLinkedList_Remove(list, dealloc);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "LinkedList\tLinkedList_GetNext(LinkedList list)",
                                    "body": "{\n\tif (!list || !value)\n\t\treturn (LINKEDLIST_EMPTY);\n\twhile (LinkedList_GetInfo(list) != value)\n\t\tlist = LinkedList_GetNext(list);\n\treturn (list);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "Generic\tLinkedList_GetInfo(LinkedList list)",
                                    "body": "{\n\tif (!list)\n\t\treturn (LINKEDLIST_EMPTY);\n\treturn (list->next);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tLinkedList_Dealloc(LinkedList head, Deallocator dealloc)",
                                    "body": "{\n\tif (!list)\n\t\treturn (GENERIC_NULL);\n\treturn (list->info);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "LinkedList\tLinkedList_GetNth(LinkedList list, size_t n)",
                                    "body": "{\n\tLinkedList\tnext;\n\n\tif (!head)\n\t\treturn ;\n\twhile (head)\n\t{\n\t\tnext = head->next;\n\t\tif (dealloc)\n\t\t\tdealloc(head->info);\n\t\tfree(head);\n\t\thead = next;\n\t}\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tLinkedList_RemoveNth(LinkedList *list, size_t n, Deallocator dealloc)",
                                    "body": "{\n\tsize_t\ti;\n\n\ti = 0;\n\twhile (i < n)\n\t{\n\t\tlist = LinkedList_GetNext(list);\n\t\tif (!list)\n\t\t\treturn (LINKEDLIST_EMPTY);\n\t\ti++;\n\t}\n\treturn (list);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "size_t\tLinkedList_Size(LinkedList list)",
                                    "body": "{\n\tif (!list || !*list)\n\t\treturn ;\n\twhile (n)\n\t{\n\t\tlist = &((*list)->next);\n\t\tn--;\n\t}\n\tLinkedList_Remove(list, dealloc);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "LinkedList\tLinkedList_Insert(LinkedList *list, Generic value, size_t index)",
                                    "body": "{\n\tsize_t\tsize;\n\n\tsize = 0;\n\twhile (list)\n\t{\n\t\tsize++;\n\t\tlist = LinkedList_GetNext(list);\n\t}\n\treturn (size);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "LinkedList\tLinkedList_GetLast(LinkedList list)",
                                    "body": "{\n\tLinkedList\tc_node;\n\tLinkedList\tn_node;\n\n\tif (!list || !*list)\n\t\treturn (LINKEDLIST_EMPTY);\n\tif (index == START)\n\t{\n\t\tLinkedList_Push(list, value);\n\t\treturn (*list);\n\t}\n\tif (index == LAST)\n\t\treturn (LinkedList_Append(list, value));\n\tc_node = LinkedList_GetNth(*list, index - 1);\n\tif (!c_node)\n\t\treturn (LINKEDLIST_EMPTY);\n\tn_node = LinkedList_Init(value);\n\tn_node->next = c_node->next;\n\tc_node->next = n_node;\n\treturn (n_node);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "",
                                    "body": "{\n\tif (!list)\n\t\treturn (LINKEDLIST_EMPTY);\n\twhile (list->next)\n\t\tlist = list->next;\n\treturn (list);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                }
                            ]
                        }
                    ]
                }
            ],
            "files": []
        },
        {
            "name": "./Algebra",
            "subfolders": [
                {
                    "name": "./Algebra/Complex",
                    "subfolders": [],
                    "files": [
                        {
                            "functions": [
                                {
                                    "doc": "/**\n * @brief \n */",
                                    "header": "t_complex\tComplex_Init(t_complex_type re, t_complex_type im)",
                                    "body": "{\n\tt_complex\tc;\n\n\tc = (t_complex)malloc(sizeof(t_complex_));\n\tif (!c)\n\t\treturn (NULL);\n\tc->re = re;\n\tc->im = im;\n\treturn (c);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tComplex_free(t_complex c)",
                                    "body": "{\n\tfree(c);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "t_complex_type\tComplex_mod(t_complex c)",
                                    "body": "{\n\tt_complex_type\tre;\n\tt_complex_type\tim;\n\n\tre = c->re;\n\tim = c->im;\n\treturn (sqrt(re * re + im * im));\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "t_complex\tComplex_add(t_complex a, t_complex b)",
                                    "body": "{\n\tt_complex\tc;\n\n\tc = Complex_Init(a->re + b->re, a->im + b->im);\n\treturn (c);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "t_complex\tComplex_sub(t_complex a, t_complex b)",
                                    "body": "{\n\tt_complex\tc;\n\n\tc = Complex_Init(a->re - b->re, a->im - b->im);\n\treturn (c);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "t_complex\tComplex_mul(t_complex a, t_complex b)",
                                    "body": "{\n\treturn (Complex_Init(a->re * b->re - a->im * b->im, a->re * b->im + a->im\n\t\t\t* b->re));\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "t_complex\tComplex_div(t_complex a, t_complex b)",
                                    "body": "{\n\tt_complex_type mod;\n\n\tmod = Complex_mod(b);\n\treturn (Complex_Init((a->re * b->re + a->im * b->im) / mod, (a->im * b->re\n\t\t\t\t- a->re * b->im) / mod));\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "./Algebra/Matrix",
                    "subfolders": [],
                    "files": [
                        {
                            "functions": [
                                {
                                    "doc": "/**\n * @brief Recursive function to calculate the determinant of a matrix\n * @param mat: Matrix to calculate the determinant\n *\n * @return The determinant of the matrix\n */",
                                    "header": "Matrix\tMatrix_Init(size_t y, size_t x)",
                                    "body": "{\n\treturn (Mat_type *)calloc(len, sizeof(Mat_type));\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "Matrix\tIdentity_matrix(size_t length, Mat_type value)",
                                    "body": "{\n\tMat_type\t**matrix;\n\n\tmatrix = (Mat_type **)malloc(y * sizeof(Mat_type *));\n\tfor (size_t i = 0; i < y; i++)\n\t\tmatrix[i] = InitRow(x);\n\treturn (matrix);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "bool\tKroneckerDelta(size_t i, size_t j)",
                                    "body": "{\n\tMatrix\tmatrix;\n\n\tmatrix = (Matrix)malloc(sizeof(Mat));\n\tif (!matrix)\n\t\treturn (MATRIX_NULL);\n\tmatrix->table = InitTable(y, x);\n\tmatrix->cols = x;\n\tmatrix->rows = y;\n\treturn (matrix);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tMatrix_SetValue(Matrix matrix, Mat_type value, size_t y, size_t x)",
                                    "body": "{\n\tMatrix\tmatrix;\n\n\tmatrix = Matrix_Init(length, length);\n\tfor (size_t i = 0; i < length; i++)\n\t\tfor (size_t j = 0; j < length; j++)\n\t\t\tMatrix_SetValue(matrix, KroneckerDelta(i, j) * value, i, j);\n\treturn (matrix);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "Matrix\tMatrix_Sum(Matrix mat, Matrix mat2)",
                                    "body": "{\n\treturn (i == j);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "Matrix\tMatrix_ScalarProduct(Matrix mat, Mat_type scalar)",
                                    "body": "{\n\tif (!matrix)\n\t\treturn ;\n\tmatrix->table[y][x] = value;\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "Matrix\tMatrixProduct(Matrix mat, Matrix mat2)",
                                    "body": "{\n\tif (!matrix)\n\t\treturn (NULL);\n\treturn (matrix->table[n]);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "Matrix\tMatrix_Suppressed(Matrix mat, size_t y, size_t x)",
                                    "body": "{\n\tMat_type\t*arr;\n\n\tarr = InitRow(matrix->rows);\n\tfor (size_t y = 0; y < matrix->rows; y++)\n\t\tarr[y] = matrix->table[y][n];\n\treturn ((Mat_type *)arr);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "Matrix\tMatrix_Transpose(Matrix mat)",
                                    "body": "{\n\tMatrix\tnewMatrix;\n\n\tif (!mat || !mat2)\n\t\treturn (MATRIX_NULL);\n\tnewMatrix = Matrix_Init(mat->rows, mat->cols);\n\tif ((mat->rows != mat2->rows) || (mat->cols != mat2->cols))\n\t{\n\t\tprintf(\"cannot be summed\");\n\t\treturn (newMatrix);\n\t}\n\tfor (size_t y = 0; y < mat->rows; y++)\n\t\tfor (size_t x = 0; x < mat->cols; x++)\n\t\t\tMatrix_SetValue(newMatrix, mat->table[y][x] + mat2->table[y][x], y,\n\t\t\t\tx);\n\treturn (newMatrix);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "Mat_type\tMatrix_TwoByTwoDet(Matrix mat)",
                                    "body": "{\n\tMatrix\tnewMatrix;\n\n\tnewMatrix = Matrix_Init(mat->rows, mat->cols);\n\tfor (size_t y = 0; y < mat->rows; y++)\n\t\tfor (size_t x = 0; x < mat->cols; x++)\n\t\t\tMatrix_SetValue(newMatrix, mat->table[y][x] * scalar, y, x);\n\treturn (newMatrix);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "Mat_type\tMatrix_SarrusDet(Matrix mat)",
                                    "body": "{\n\tMatrix\tnewMatrix;\n\n\tnewMatrix = Matrix_Init(mat->rows, mat2->cols);\n\tif (mat->cols != mat2->rows)\n\t{\n\t\tprintf(\"Cannot be multiplied, incompatible dimensions\");\n\t\treturn (newMatrix);\n\t}\n\tfor (size_t y = 0; y < mat->rows; y++)\n\t\tfor (size_t x = 0; x < mat->cols; x++)\n\t\t\tfor (size_t k = 0; k < mat->cols; k++)\n\t\t\t\tnewMatrix->table[y][x] += mat->table[y][k] * mat->table[k][x];\n\treturn (newMatrix);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "Mat_type\tMatrix_LaplaceDet(Matrix mat)",
                                    "body": "{\n\tconst size_t\tnew_y = mat->rows - 1;\n\tconst size_t\tnew_x = mat->cols - 1;\n\tsize_t\t\t\tx_count;\n\tsize_t\t\t\ty_count;\n\tMatrix\t\t\tsubMatrix;\n\n\tx_count = 0;\n\tif (mat->rows < 2 && mat->cols < 2)\n\t{\n\t\tprintf(\"Mat cannot be modified (insufficient size)\");\n\t\treturn (mat);\n\t}\n\tif (y >= mat->rows || x >= mat->cols)\n\t{\n\t\tprintf(\"Mat cannot be modified (out of bounds)\");\n\t\treturn (mat);\n\t}\n\tx_count = 0, y_count = 0;\n\tsubMatrix = Matrix_Init(new_y, new_x);\n\tfor (size_t i = 0; i < mat->rows && y_count < new_y; i++)\n\t{\n\t\tfor (size_t j = 0; j < mat->cols; j++)\n\t\t{\n\t\t\tif (i != y && j != x)\n\t\t\t{\n\t\t\t\tMatrix_SetValue(subMatrix, mat->table[i][j], y_count,\n\t\t\t\t\tx_count++);\n\t\t\t\tif (x_count >= new_x)\n\t\t\t\t{\n\t\t\t\t\tx_count = 0;\n\t\t\t\t\ty_count++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn (subMatrix);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tMatrix_Fill(Matrix matrix, Mat_type value, size_t y0, size_t x0)",
                                    "body": "{\n\tMatrix\tnewMatrix;\n\n\tif (!mat)\n\t\treturn (MATRIX_NULL);\n\tnewMatrix = Matrix_Init(mat->cols, mat->rows);\n\tfor (size_t row = 0; row < mat->rows; row++)\n\t\tfor (size_t col = 0; col < mat->cols; col++)\n\t\t\tMatrix_SetValue(newMatrix, mat->table[row][col], col, row);\n\treturn (newMatrix);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tMatrix_Print(Matrix matrix)",
                                    "body": "{\n\tMat_type\t**table;\n\tdouble\t\tmainDiagonal;\n\tdouble\t\tsecondaryDiagonal;\n\n\tif (!mat || mat->rows != 2 || mat->cols != 2)\n\t{\n\t\terrno = EINVAL;\n\t\tperror(TWOBTWO_ERROR);\n\t\treturn (0);\n\t}\n\ttable = mat->table;\n\tmainDiagonal = table[0][0] * table[1][1];\n\tsecondaryDiagonal = table[0][1] * table[1][0];\n\treturn (mainDiagonal - secondaryDiagonal);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tMatrix_Free(Matrix matrix)",
                                    "body": "{\n\tconst Mat_type\tmainDiagonal = mat->table[0][0] * mat->table[1][1]\n\t\t\t* mat->table[2][2];\n\tconst Mat_type\tsecondaryDiagonal = mat->table[0][1] * mat->table[1][2]\n\t\t\t* mat->table[2][0];\n\tconst Mat_type\ttertiaryDiagonal = mat->table[0][2] * mat->table[1][0]\n\t\t\t* mat->table[2][1];\n\tconst Mat_type\tmainDiagonal2 = mat->table[0][2] * mat->table[1][1]\n\t\t\t* mat->table[2][0];\n\tconst Mat_type\tsecondaryDiagonal2 = mat->table[0][0] * mat->table[1][2]\n\t\t\t* mat->table[2][1];\n\tconst Mat_type\ttertiaryDiagonal2 = mat->table[0][1] * mat->table[1][0]\n\t\t\t* mat->table[2][2];\n\n\tif (!mat || mat->rows != 3 || mat->cols != 3)\n\t{\n\t\terrno = EINVAL;\n\t\tperror(SARRUS_ERROR);\n\t\treturn (0);\n\t}\n\treturn (mainDiagonal + secondaryDiagonal + tertiaryDiagonal - mainDiagonal2\n\t\t- secondaryDiagonal2 - tertiaryDiagonal2);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "Mat_type\tMatrix_GetValue(Matrix matrix, size_t y, size_t x)",
                                    "body": "{\n\tMat_type\tdet;\n\tMatrix\t\tsubMatrix;\n\n\tif (!mat)\n\t\treturn (0);\n\tif (mat->rows != mat->cols)\n\t{\n\t\terrno = EINVAL;\n\t\tperror(SQUARE_ERROR);\n\t\treturn (0);\n\t}\n\tif (mat->rows == 2)\n\t\treturn (Matrix_TwoByTwoDet(mat));\n\tif (mat->rows == 3)\n\t\treturn (Matrix_SarrusDet(mat));\n\tdet = 0;\n\tfor (size_t i = 0; i < mat->rows; i++)\n\t{\n\t\tsubMatrix = Matrix_Suppressed(mat, 0, i);\n\t\tdet += mat->table[0][i] * Matrix_LaplaceDet(subMatrix) * (!(i & 1) ? 1 :\n\t\t\t\t-1);\n\t\tMatrix_Free(subMatrix);\n\t}\n\treturn (det);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "Matrix\tMatrix_Inverse(Matrix mat)",
                                    "body": "{\n\tsize_t\tx0_copy;\n\n\tif (!matrix)\n\t\treturn ;\n\tx0_copy = x0;\n\twhile (y0 < matrix->rows)\n\t{\n\t\twhile (x0 < matrix->cols)\n\t\t{\n\t\t\tMatrix_SetValue(matrix, value, y0, x0);\n\t\t\tx0++;\n\t\t}\n\t\ty0++;\n\t\tx0 = x0_copy;\n\t}\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "",
                                    "body": "{\n\tprintf(\"Mat:\\n\");\n\tfor (size_t y = 0; y < matrix->rows; y++)\n\t{\n\t\tfor (size_t x = 0; x < matrix->cols; x++)\n\t\t\tprintf(\"%lf\\t\", matrix->table[y][x]);\n\t\tprintf(\"\\n\");\n\t}\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "",
                                    "body": "{\n\tfor (size_t i = 0; i < matrix->rows; i++)\n\t\tfree(matrix->table[i]);\n\tfree(matrix->table);\n\tfree(matrix);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "",
                                    "body": "{\n\treturn (matrix->table[y][x]);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "",
                                    "body": "{\n\tMatrix\tnewMatrix;\n\tMatrix\tsup;\n\n\tnewMatrix = Matrix_Init(mat->cols, mat->rows);\n\tfor (size_t i = 0; i < newMatrix->cols; i++)\n\t\tfor (size_t j = 0; j < newMatrix->rows; j++)\n\t\t{\n\t\t\tsup = Matrix_Suppressed(mat, i, j);\n\t\t\tMatrix_SetValue(newMatrix, Matrix_LaplaceDet(sup), i, j);\n\t\t\tMatrix_Free(sup);\n\t\t}\n\treturn (newMatrix);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                }
                            ]
                        }
                    ]
                },
                {
                    "name": "./Algebra/Vector",
                    "subfolders": [],
                    "files": [
                        {
                            "functions": [
                                {
                                    "doc": "",
                                    "header": "t_uvector2\tUVector2_init(uint64_t x, uint64_t y)",
                                    "body": "{\n\tt_uvector2\tvector;\n\n\tvector = malloc(sizeof(t_uvector2_));\n\tif (!vector)\n\t\treturn (NULL);\n\tvector->x = x;\n\tvector->y = y;\n\treturn (vector);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tUVector2_free(t_uvector2 vector)",
                                    "body": "{\n\tif (!vector)\n\t\treturn ;\n\tfree(vector);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                }
                            ]
                        },
                        {
                            "functions": [
                                {
                                    "doc": "",
                                    "header": "Vector2\tVector2_init(VectorType x, VectorType y)",
                                    "body": "{\n\treturn (Vector2)malloc(sizeof(Vector_2));\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "Vector3\tVector3_init(VectorType x, VectorType y, VectorType z)",
                                    "body": "{\n\treturn (Vector3)malloc(sizeof(Vector_3));\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "Vector2\tVector2_Sum(Vector2 v, Vector2 v2)",
                                    "body": "{\n\tVector2\tvector;\n\n\tvector = AllocateVector2();\n\tif (!vector)\n\t\treturn (NULL);\n\tvector->x = x;\n\tvector->y = y;\n\treturn (vector);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "Vector3\tVector3_Sum(Vector3 v, Vector3 v2)",
                                    "body": "{\n\tVector3\tvector;\n\n\tvector = AllocateVector3();\n\tif (!vector)\n\t\treturn (NULL);\n\tvector->x = x;\n\tvector->y = y;\n\tvector->z = z;\n\treturn (vector);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "Vector2\tVector2_Mul(VectorType num, Vector2 v)",
                                    "body": "{\n\treturn (Vector2_init(v->x + v2->x, v->y + v2->y));\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "Vector3\tVector3_Mul(VectorType num, Vector3 v)",
                                    "body": "{\n\treturn (Vector3_init(v->x + v2->x, v->y + v2->y, v->z + v2->z));\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "VectorType\tVector2_ScalarProduct(Vector2 v, Vector2 v2)",
                                    "body": "{\n\treturn (Vector2_init(num * (v->x), num * (v->y)));\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "VectorType\tVector3_ScalarProduct(Vector3 v, Vector3 v2)",
                                    "body": "{\n\treturn (Vector3_init(v->x *= num, v->y *= num, v->z *= num));\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "Vector3\tVector3_VectorialProduct(Vector3 v, Vector3 v2)",
                                    "body": "{\n\treturn (v->x * v2->x + v2->y * v2->y);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "VectorType\tVector2_Module(Vector2 v)",
                                    "body": "{\n\treturn (v->x * v2->x + v2->y * v2->y + v->z * v2->z);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "VectorType\tVector3_Module(Vector3 v)",
                                    "body": "{\n\treturn (Vector3_init(v->y * v2->z + v->z * v2->y, v->z * v2->x + v->x\n\t\t\t* v2->z, v->x * v2->y + v->y * v2->x));\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "Vector2\tVector2_Normalized(Vector2 v)",
                                    "body": "{\n\treturn (sqrt(pow(v->x, 2) + pow(v->y, 2)));\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "Vector3\tVector3_Normalized(Vector3 v)",
                                    "body": "{\n\treturn (sqrt(pow(v->x, 2) + pow(v->y, 2) + pow(v->z, 2)));\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tVector2_Print(Vector2 v)",
                                    "body": "{\n\tconst VectorType\tmodule = Vector2_Module(v);\n\n\treturn (Vector2_init(v->x / module, v->y / module));\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tVector3_Print(Vector3 v)",
                                    "body": "{\n\tconst VectorType\tmodule = Vector3_Module(v);\n\n\treturn Vector3_init(v->x / module, v->y / module, v->z / module);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tVector2_Free(Vector2 v)",
                                    "body": "{\n\tprintf(\"Vector:\\nx: %lf y: %lf\\n\", v->x, v->y);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "void\tVector3_Free(Vector3 v)",
                                    "body": "{\n\tprintf(\"Vector:\\nx: %lf y: %lf z: %lf\\n\", v->x, v->y, v->z);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "",
                                    "body": "{\n\tfree(v);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                },
                                {
                                    "doc": "",
                                    "header": "",
                                    "body": "{\n\tfree(v);\n}",
                                    "DOC_PATTERN": "(\\/\\*\\*[^\\/]*\\*\\/)",
                                    "FUNCTION_HEADER_PATTERN": "(\\w+\\s+\\w+\\((?:\\s*\\w+\\s+\\S+[,]*)+\\))",
                                    "BRACKET_PATTERN": "(\\{(?:[^{}]|(?R))*\\})"
                                }
                            ]
                        }
                    ]
                }
            ],
            "files": []
        }
    ],
    "files": []
}